{
    "event": false,
    "locked": true,
    "starred": false,
    "name": "cube",
    "command": "// TODO: axis / offset can be derived from color\n// TODO: convert highscores to SQL -> direct copy at first\n\nconst centers = [\n    // U B R F L D\n    { color: 0, axis: 'y', offset: -1 },\n    { color: 1, axis: 'z', offset: -1 },\n    { color: 2, axis: 'x', offset: 1 },\n    { color: 3, axis: 'z', offset: 1 },\n    { color: 4, axis: 'x', offset: -1 },\n    { color: 5, axis: 'y', offset: 1 },\n];\n\nconst edges = [\n    // UB UR UF UL\n    [ { color: 1, axis: 'z', offset: -1 }, { color: 0, axis: 'y', offset: -1 } ],\n    [ { color: 2, axis: 'x', offset: 1 }, { color: 0, axis: 'y', offset: -1 } ],\n    [ { color: 3, axis: 'z', offset: 1 }, { color: 0, axis: 'y', offset: -1 } ],\n    [ { color: 4, axis: 'x', offset: -1 }, { color: 0, axis: 'y', offset: -1 } ],\n    // BR FR FL BL\n    [ { color: 2, axis: 'x', offset: 1 }, { color: 1, axis: 'z', offset: -1 } ],\n    [ { color: 2, axis: 'x', offset: 1 }, { color: 3, axis: 'z', offset: 1 } ],\n    [ { color: 4, axis: 'x', offset: -1 }, { color: 3, axis: 'z', offset: 1 } ],\n    [ { color: 4, axis: 'x', offset: -1 }, { color: 1, axis: 'z', offset: -1 } ],\n    // DB DR DF DL\n    [ { color: 1, axis: 'z', offset: -1 }, { color: 5, axis: 'y', offset: 1 } ],\n    [ { color: 2, axis: 'x', offset: 1 }, { color: 5, axis: 'y', offset: 1 } ],\n    [ { color: 3, axis: 'z', offset: 1 }, { color: 5, axis: 'y', offset: 1 } ],\n    [ { color: 4, axis: 'x', offset: -1 }, { color: 5, axis: 'y', offset: 1 } ],\n];\n\nconst corners = [\n    // UBR URF UFL ULB\n    [\n        { color: 2, axis: 'x', offset: 1 },\n        { color: 0, axis: 'y', offset: -1 },\n        { color: 1, axis: 'z', offset: -1 },\n    ],\n    [\n        { color: 2, axis: 'x', offset: 1 },\n        { color: 0, axis: 'y', offset: -1 },\n        { color: 3, axis: 'z', offset: 1 },\n    ],\n    [\n        { color: 4, axis: 'x', offset: -1 },\n        { color: 0, axis: 'y', offset: -1 },\n        { color: 3, axis: 'z', offset: 1 },\n    ],\n    [\n        { color: 4, axis: 'x', offset: -1 },\n        { color: 0, axis: 'y', offset: -1 },\n        { color: 1, axis: 'z', offset: -1 },\n    ],\n    // DRB DFR DLF DBL\n    [\n        { color: 2, axis: 'x', offset: 1 },\n        { color: 5, axis: 'y', offset: 1 },\n        { color: 1, axis: 'z', offset: -1 },\n    ],\n    [\n        { color: 2, axis: 'x', offset: 1 },\n        { color: 5, axis: 'y', offset: 1 },\n        { color: 3, axis: 'z', offset: 1 },\n    ],\n    [\n        { color: 4, axis: 'x', offset: -1 },\n        { color: 5, axis: 'y', offset: 1 },\n        { color: 3, axis: 'z', offset: 1 },\n    ],\n    [\n        { color: 4, axis: 'x', offset: -1 },\n        { color: 5, axis: 'y', offset: 1 },\n        { color: 1, axis: 'z', offset: -1 },\n    ],\n];\n\nconst cube = {\n    edges,\n    corners,\n    centers,\n};\n\n// U B R F L D\nconst moveList = {\n    R: {\n        edges: [5, 9, 4, 1],\n        corners: [5, 4, 0, 1],\n        centre: 2,\n        axis: 'x',\n    },\n    U: {\n        edges: [3, 2, 1, 0],\n        corners: [3, 2, 1, 0],\n        centre: 0,\n        axis: 'y',\n    },\n    F: {\n        edges: [6, 10, 5, 2],\n        corners: [1, 2, 6, 5],\n        centre: 3,\n        axis: 'z',\n    },\n    L: {\n        edges: [3, 7, 11, 6],\n        corners: [2, 3, 7, 6],\n        centre: 4,\n        axis: 'x',\n        axisFlip: true,\n    },\n    B: {\n        edges: [4, 8, 7, 0],\n        corners: [4, 7, 3, 0],\n        centre: 1,\n        axis: 'z',\n        axisFlip: true,\n    },\n    D: {\n        edges: [8, 9, 10, 11],\n        corners: [4, 5, 6, 7],\n        centre: 5,\n        axis: 'y',\n        axisFlip: true,\n    },\n    M: {\n        centers: [0, 1, 5, 3],\n        edges: [2, 0, 8, 10],\n        axis: 'x',\n        axisFlip: true,\n    },\n    E: {\n        centers: [3, 4, 1, 2],\n        edges: [4, 5, 6, 7],\n        axis: 'y',\n        axisFlip: true,\n    },\n    S: {\n        centers: [4, 5, 2, 0],\n        edges: [3, 11, 9, 1],\n        axis: 'z',\n    },\n    r: { moves: [toObject(`R`), toObject(`M'`)] },\n    l: { moves: [toObject(`L`), toObject(`M`)] },\n    f: { moves: [toObject(`F`), toObject(`S`)] },\n    b: { moves: [toObject(`B`), toObject(`S'`)] },\n    u: { moves: [toObject(`U`), toObject(`E'`)] },\n    d: { moves: [toObject(`D`), toObject(`E`)] },\n    x: { moves: [toObject(`R`), toObject(`M'`), toObject(`L'`)] },\n    y: { moves: [toObject(`U`), toObject(`E'`), toObject(`D'`)] },\n    z: { moves: [toObject(`F`), toObject(`S`), toObject(`B'`)] },\n};\n\nfunction getMove(moveRaw) {\n    const { move, order } = toObject(moveRaw);\n    if (!moveList[move]) throw new Error(`invalid move ${move}`);\n    const {\n        corners,\n        edges,\n        centers,\n        centre,\n        axis,\n        axisFlip,\n        moves,\n    } = moveList[move];\n\n    // calculate transforms\n    const transforms = [];\n    corners && transforms.push(...corners.map(index => cube.corners[index]));\n    edges && transforms.push(...edges.map(index => cube.edges[index]));\n    centers && transforms.push(...centers.map(index => cube.centers[index]));\n    typeof centre !== 'undefined' && transforms.push(cube.centers[centre]);\n    const axisOrder = axisFlip ? -1 : 1;\n    const extraMoves = moves && (\n        moves.map(move => getMove(applyOrder(clone(move), order), cube))\n    );\n\n    // swap stickers / clean up move\n    function apply() {\n        extraMoves && extraMoves.forEach(move => move.apply());\n        if (edges) {\n            doCycle(cube.edges, order, edges, centers ? 'z' : axis);\n        }\n        if (centers) {\n            doCycle(cube.centers, order, centers);\n        }\n        if (corners) {\n            doCycle(cube.corners, order, corners, axis);\n        }\n    }\n\n    return {\n        apply,\n        transforms,\n        axis,\n        source: { move, order },\n    };\n}\n\nfunction getMoves(moves) {\n    return splitMoves(moves).map(move => getMove(move, cube));\n}\n\nfunction splitMoves(str) {\n    if (typeof str !== 'string') return str;\n    return str.split(/(\\ww?\\d?'?)/).filter(d => d.trim());\n}\n\nfunction toObject(move) {\n    if (typeof move !== 'string') return move;\n    if (move[1] === 'w') move = `${move[0].toLowerCase()}${move.slice(2) || ''}`;\n    return {\n        move: move[0],\n        order: {\n            '\\'': -1,\n            '2\\'': -2,\n            '2': 2,\n        }[move.slice(1)] || 1,\n    };\n}\n\nfunction clone(move) {\n    return Object.assign({}, move);\n}\n\nfunction applyOrder(move, order) {\n    if (order === 1) return move;\n    if (order === -1) {\n        move.order = move.order === 2 ? 2 : -move.order;\n    }\n    if (order === 2) {\n        move.order = move.order === 2 ? 0 : 2;\n    }\n    return move;\n}\n\n\nconst cornerSwaps = {\n    x: [1, 2],\n    y: [0, 2],\n    z: [0, 1],\n};\n\nfunction doCycle(arr, order, cycle, axis) {\n    if (order === 0) return;\n    if (order === -1 || order === 3) {\n        cycle = [...cycle].reverse();\n    }\n    if (order === 2 || order === -2) {\n        doCycle(arr, 1, cycle, axis);\n    }\n\n    // cycles\n    for (let i = 0; i < cycle.length - 1; i++) {\n        swapPiece(arr, cycle[i], cycle[i + 1]);\n    }\n\n    // corner 'twists'\n    if (arr[0].length === 3) {\n        for (let i = 0; i < cycle.length; i++) {\n            swapSticker(arr[cycle[i]], ...cornerSwaps[axis]);\n        }\n    }\n    // edge flips\n    else if (axis === 'z') {\n        for (let i = 0; i < cycle.length; i++) {\n            swapSticker(arr[cycle[i]], 0, 1);\n        }\n    }\n}\n\nfunction swapPiece(arr, first, second) {\n    if (Array.isArray(arr[first])) {\n        const tmpColors = arr[first].map(d => d.color);\n        arr[first].forEach((sticker, i) => { sticker.color = arr[second][i].color; });\n        arr[second].forEach((sticker, i) => { sticker.color = tmpColors[i]; });\n    } else {\n        swapSticker(arr, first, second)\n    }\n}\n\nfunction swapSticker(arr, first, second) {\n    const tmp = arr[first].color;\n    arr[first].color = arr[second].color;\n    arr[second].color = tmp;\n}\n\nfunction isSolved() {\n    const { centers, edges, corners } = cube;\n    const lookup = {};\n    centers.forEach(({ color, axis, offset }) => {\n        lookup[`${axis}|${offset}`] = color;\n    });\n    const pieces = edges.concat(corners);\n    for (let i = 0; i < pieces.length; i++) {\n        for (let j = 0; j < pieces[i].length; j++) {\n            const { axis, offset, color } = pieces[i][j];\n            if (color !== lookup[`${axis}|${offset}`]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\n// IRC stuff\n\nconst { from } = IRC.message;\n\nfunction saveCube() {\n    store.set(from, JSON.stringify(cube));\n}\n\nfunction loadCube() {\n    const next = store.get(from);\n    if (next) {\n        Object.assign(cube, JSON.parse(next));\n    }\n}\n\nfunction ksim(str) {\n    const keys = [\n        ['i', 'R'], ['k', 'R\\''], ['8', 'R2'], ['u', 'r'], ['m', 'r\\''], ['j', 'U'],\n        ['f', 'U\\''], ['s', 'D'], ['l', 'D\\''], ['n', 'F'], ['v', 'F\\''], ['o', 'B\\''],\n        ['w', 'B'], ['g', 'M\\''], ['H', 'E2'], ['G', 'E2'], ['h', 'M'], ['d', 'L'], \n        ['e', 'L\\''], ['3', 'L2'], ['c', 'l'], ['r', 'l\\''], [';', 'y'], ['a', 'y\\''], \n        ['y', 'x'], ['t', 'x\\''], ['p', 'z'], ['q', 'z\\''],\n    ];\n    const lookup = Object.fromEntries(keys);\n    return str.replace(new RegExp(keys.map(d=>d[0]).join`|`,'g'), d => lookup[d]);\n}\n\t\nfunction heise(str) {\n    const keys = [\n        ['i', 'R'], ['k', 'R\\''], ['j', 'U'], ['f', 'U\\''], ['d', 'L'], ['e', 'L\\''], ['u', 'r'], ['m', 'r\\''], ['v', 'l'], ['r', 'l\\''], ['h', 'F'], ['g', 'F\\''], ['s', 'D'], ['l', 'D\\''], [';', 'y'], ['a', 'y\\''], ['w', 'B'], ['o', 'B\\''], ['y', 'x'], ['n', 'x\\''], ['p', 'z'], ['q', 'z\\''],\n    ];\n    const lookup = Object.fromEntries(keys);\n    return str.replace(new RegExp(keys.map(d=>d[0]).join`|`,'g'), d => lookup[d]);\n}\n\nfunction applyKeymap(moves) {\n    const moveType = IRC.command.params?.[0]?.trim();\n    if (moveType === 'ksim') return ksim(moves);\n    if (moveType === 'heise') return heise(moves);\n    return moves;\n}\n\nfunction doMoves(moves) {\n    getMoves(applyKeymap(moves)).forEach(move => move.apply());\n}\n\n// render\n\nconst colors = 'wbrgoy';\n\nfunction sticker(obj) { return `{${colors[obj.color]}}██{/}`; }\nfunction crnr(x, y) { return sticker(cube.corners[x][y]); }\nfunction edge(x, y) { return sticker(cube.edges[x][y]); }\nfunction cntr(x) { return sticker(cube.centers[x]); }\n\nfunction renderQCube(message = '') {\n    print([\n        [sticker(cube.corners[3][0]),sticker(cube.corners[3][1]),sticker(cube.edges[0][1]),sticker(cube.corners[0][1]),sticker(cube.corners[0][0])].join`` + ` ${message}`,\n        [sticker(cube.edges[3][0]),sticker(cube.edges[3][1]),sticker(cube.centers[0]),sticker(cube.edges[1][1]),sticker(cube.edges[1][0])].join``,\n        [sticker(cube.corners[2][0]),sticker(cube.corners[2][1]),sticker(cube.edges[2][1]),sticker(cube.corners[1][1]),sticker(cube.corners[1][0])].join``,\n        [sticker(cube.corners[2][0]),sticker(cube.corners[2][2]),sticker(cube.edges[2][0]),sticker(cube.corners[1][2]),sticker(cube.corners[1][0])].join``,\n        [sticker(cube.edges[6][0]),sticker(cube.edges[6][1]),sticker(cube.centers[3]),sticker(cube.edges[5][1]),sticker(cube.edges[5][0])].join``,\n        [sticker(cube.corners[6][0]),sticker(cube.corners[6][2]),sticker(cube.edges[0xA][0]),sticker(cube.corners[5][2]),sticker(cube.corners[5][0])].join``,\n    ].join`\\n`)\n}\n\nfunction renderQCubeRoux(message = '') {\n    const spaces = '    ';\n    print([\n        [spaces, sticker(cube.corners[3][0]),sticker(cube.corners[3][1]),sticker(cube.edges[0][1]),sticker(cube.corners[0][1]),sticker(cube.corners[0][0]),'  ',edge(8,0)].join`` + ` ${message}`,\n        [spaces, sticker(cube.edges[3][0]),sticker(cube.edges[3][1]),sticker(cube.centers[0]),sticker(cube.edges[1][1]),sticker(cube.edges[1][0]),'  ',edge(8,1)].join``,\n        [spaces, sticker(cube.corners[2][0]),sticker(cube.corners[2][1]),sticker(cube.edges[2][1]),sticker(cube.corners[1][1]),sticker(cube.corners[1][0])].join``,\n        [crnr(3,0),edge(3,0),crnr(2,0),crnr(2,2),edge(2,0),crnr(1,2),crnr(1,0),edge(1,0),crnr(0,0)].join``,\n        [edge(7,0),cntr(4),edge(6,0),edge(6,1),cntr(3),  edge(5,1),edge(5,0),cntr(2),edge(4,0)].join``,\n        [crnr(7,0),edge(11,0),crnr(6,0),crnr(6,2),edge(10,0),crnr(5,2),crnr(5,0),edge(9,0),crnr(4,0)].join``,\n    ].join`\\n`)\n}\n\nfunction renderT(message = '') {\n    const spaces = '      ';\n    print([\n        [spaces,crnr(3,1),edge(0,1),crnr(0,1)].join`` + ` ${message}`,\n        [spaces,edge(3,1),cntr(0),  edge(1,1)].join``,\n        [spaces,crnr(2,1),edge(2,1),crnr(1,1)].join``,\n        [crnr(3,0),edge(3,0),crnr(2,0),crnr(2,2),edge(2,0),crnr(1,2),crnr(1,0),edge(1,0),crnr(0,0)].join``,\n        [edge(7,0),cntr(4),edge(6,0),edge(6,1),cntr(3),  edge(5,1),edge(5,0),cntr(2),edge(4,0)].join``,\n        [crnr(7,0),edge(11,0),crnr(6,0),crnr(6,2),edge(10,0),crnr(5,2),crnr(5,0),edge(9,0),crnr(4,0)].join``,\n    ].join`\\n`)\n}\n\nfunction renderMini(message = '') {\n    function sticker(obj) { return colors[obj.color]; }\n    function crunch([l1, l2]) { return l1.map((d, i) => `{${d},${l2[i]}}▀{/}`).join``; }\n    print([\n        crunch([[sticker(cube.corners[3][0]),sticker(cube.corners[3][1]),sticker(cube.edges[0][1]),sticker(cube.corners[0][1]),sticker(cube.corners[0][0])],\n        [sticker(cube.edges[3][0]),sticker(cube.edges[3][1]),sticker(cube.centers[0]),sticker(cube.edges[1][1]),sticker(cube.edges[1][0])]]) + ` ${message}`,\n        crunch([[sticker(cube.corners[2][0]),sticker(cube.corners[2][1]),sticker(cube.edges[2][1]),sticker(cube.corners[1][1]),sticker(cube.corners[1][0])],\n        [sticker(cube.corners[2][0]),sticker(cube.corners[2][2]),sticker(cube.edges[2][0]),sticker(cube.corners[1][2]),sticker(cube.corners[1][0])]]),\n        crunch([[sticker(cube.edges[6][0]),sticker(cube.edges[6][1]),sticker(cube.centers[3]),sticker(cube.edges[5][1]),sticker(cube.edges[5][0])],\n        [sticker(cube.corners[6][0]),sticker(cube.corners[6][2]),sticker(cube.edges[0xA][0]),sticker(cube.corners[5][2]),sticker(cube.corners[5][0])]]),\n    ].join`\\n`)\n}\n\nfunction renderMiniT(message = '') {\n    function sticker(obj) { return colors[obj.color]; }\n    function crnr(x, y) { return sticker(cube.corners[x][y]); }\n    function edge(x, y) { return sticker(cube.edges[x][y]); }\n    function cntr(x) { return sticker(cube.centers[x]); }\n    function crunch(l1, l2) { return l1.map((d, i) => `{${d},${l2[i]}}▀{/}`).join``; }\n    function crunch1(l) { return l.map(d => `{${d}}▄{/}`).join``; }\n    const spaces = '   ';\n    print([\n        spaces + crunch([crnr(3,1), edge(0,1), crnr(0,1)], [edge(3,1), cntr(0), edge(1,1)]) + ` ${message}`,\n        crunch1([crnr(3,0), edge(3,0), crnr(2,0)])\n          + crunch([crnr(2,1), edge(2,1), crnr(1,1)], [crnr(2,2), edge(2,0),  crnr(1,2)])\n          + crunch1([crnr(1,0), edge(1,0), crnr(0,0)]),\n        crunch([edge(7,0), cntr(4), edge(6,0), edge(6,1), cntr(3), edge(5,1), edge(5,0), cntr(2), edge(4,0)],\n          [crnr(7,0), edge(11,0), crnr(6,0), crnr(6,2), edge(10,0), crnr(5,2), crnr(5,0), edge(9,0), crnr(4,0)])\n    ].join`\\n`)\n}\n\n\nfunction mini() { // legacy command?\n    doMoves(input);\n    renderMini();\n}\n\nfunction view(view) {\n    if (!view || !['qcube','qcube-roux', 'mini','T','miniT'].includes(view.trim())) {\n        throw `usage: ${IRC.colors.cmd('cube.view', 'qcube|qcube-roux|mini|T|miniT')}`;\n    }\n    store.set(`${from}:view`, view);\n    print(`View for ${from} set to ${view}`);\n}\n\nfunction getView() { return store.get(`${from}:view`) || 'qcube'; }\n\nfunction render(message) {\n    const view = getView();\n    if (view === 'mini') return renderMini(message);\n    else if (view === 'T') return renderT(message);\n    else if (view === 'miniT') return renderMiniT(message);\n    else if (view === 'qcube-roux') return renderQCubeRoux(message);\n    return renderQCube(message);\n}\n\n// solving / scramble / timer\n\nconst scrambler = IRC.require('scramble');\n\nfunction scramble(type) {\n    type = type.toUpperCase().trim();\n    !['LL', 'LSE', 'TEST'].includes(type) && (type = '3x3');\n\n    const scramble = {\n        TEST: `RU`,\n        LL: scrambler.getLLScramble(),\n        LSE: `xy'` + scrambler.getLSEScramble() + ['', ' M2'][0|Math.random()*2],\n    }[type] || (() => scrambler.getRandomScramble())();\n\n    doMoves(scramble);\n\n    store.save(`${from}:solve`, {\n        moves: [],\n        scrambleTime: +(new Date),\n        startTime: undefined,\n        scramble,\n        view: getView(),\n        type,\n    });\n\n    saveCube();\n    render(`${type} scramble`);\n}\n\nfunction apply(inputMoves) {\n    loadCube();\n    doMoves(inputMoves);\n    saveCube();\n\n    const state = store.load(`${from}:solve`, false);\n    let message;\n    if (state) {\n        let { moves, startTime, ...other } = state;\n\n        const converted = applyKeymap(inputMoves);\n\n        moves.push([+(new Date), converted, inputMoves]);\n\n        if (!startTime) {\n            if (getMoves(converted).some(move => !'xyz'.includes(move.source.move))) {\n                // if there's a non inspection move\n                startTime = +(new Date);\n                message = 'timer started!';\n            }\n        } else {\n            message = renderDiff(startTime, +new Date)\n        }\n\n        store.save(`${from}:solve`, {\n            moves,\n            startTime,\n            ...other\n        });\n\n\n        if (isSolved()) return solved();\n    }\n\n    render(message);\n}\n\nfunction renderDiff(startTime, endTime) {\n    const { intervalToDuration } = require('date-fns@2.28.0');\n    const duration = intervalToDuration({ start: new Date(startTime), end: new Date(endTime) });\n    return `${duration.minutes}:${String(duration.seconds).padStart(2, '0')}`;\n}\n\nfunction solved() {\n    const { moves, startTime, scrambleTime, scramble, view, type } = store.load(`${from}:solve`);\n    const endTime = +(new Date);\n    const score = endTime - startTime;\n    render(`solved in ${renderDiff(startTime, endTime)}!`);\n\n    const scores = store.load(`scores:${type}`, {});\n    const oldScore = scores[from] || Infinity;\n\n    if (score < oldScore) {\n        scores[from] = score;\n        store.save(`scores:${type}`, scores);\n        const key = type === '3x3' ? `${from}:solution` : `${from}:solution:${type}`;\n        store.save(key, {\n            scrambleTime, startTime, endTime, score, scramble, moves, view, type\n        });\n        print(`{g}new pb!{/}`);\n        print(`${IRC.colors.nick(from, false)} got a new ${type} pb of {dc}${renderDiff(startTime, endTime)}{/}!`, { target: '#rubik' })\n    }\n\n    store.save(`${from}:solve`, false);\n}\n\nfunction scores(query) {\n    const type = query.trim() || '3x3';\n    const scores = Object.entries(store.load(`scores:${type}`, {}))\n        .map(([name, score]) => {\n            const solution = store.load(`${name}:solution`);\n          \t// if (['eyeoh'].includes(name)) {\n             \t// name += '*'; \n            // }\n            return ({ name, score, extra: solution.view, solution });\n        });\n\n    print(IRC.require('module.leaderboard')({\n        title: `${type} Leaderboard`,\n        scores,\n        reverse: true,\n        limit: 10,\n        fmtNum: (score, { solution: { startTime, endTime } }) => renderDiff(startTime, endTime),\n    }));\n}\n\nfunction solution(query) {\n    const [name, ...etc] = query.trim().split(' ');\n    const params = etc.join(' ');\n    const solution = store.load(`${name}:solution`)\n    if (!solution) throw `no solution for ${name}`\n    const { \n        moves,\n        scrambleTime,\n        startTime,\n        endTime,\n        scramble,\n        view,\n        type,\n    } = solution;\n\n    const alg = str => str.replace(/'/g, '-').replace(/\\s+/g, '_');\n\n    const link = `https://alg.cubing.net/?setup=${alg(scramble)}&alg=${moves.map(([diff, m]) => alg(m) + '____//_' + renderDiff(startTime, diff)).join('%0A')}`;\n\n    if (params.includes('--link')) return print(IRC.colors.link(link));\n\n    const output = `\nevent: ${type}\nsolve time: ${renderDiff(startTime, endTime)}\ninspection time: ${scrambleTime && renderDiff(scrambleTime, startTime)}\nscramble: ${scramble}\nview: ${view}\n\n${moves.map(([diff, moveList, inputMoves]) => \n    `${renderDiff(startTime, diff)} ${moveList} ${inputMoves && (moveList !== inputMoves) ? `${inputMoves}`: ''}`).join`\\n`}\n\n${link}\n\n    `.trim();\n\n    print(IRC.require('module.paste')(output));\n}\n\nif (IRC.command.path === 'cube') {\n    doMoves(input);\n    render();\n} else {\n    module.exports = { scramble, render, apply, getMoves, doMoves, mini, view, scores, solution };\n}"
}