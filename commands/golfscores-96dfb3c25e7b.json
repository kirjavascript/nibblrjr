{
    "name": "golf.scores",
    "command": "const { getLeaderboard } = IRC.require('golf.store');\nconst { getTaskUnchecked, taskList, taskListDisplay } = IRC.require('golf.tasks');\nconst leaderboard = IRC.require('module.leaderboard');\n\nconst [type, modifiers = ''] = (input.trim() || IRC.message.from).split` `;\nconst showAll = modifiers.includes('all');\nconst showPosition = modifiers.includes('position');\nif (type === 'global') throw 'coming soon';\n\nconst task = getTaskUnchecked(type);\n\nif (task) {\n    const scores = getLeaderboard(type)\n        .map(entry => ({\n            score: entry.bytes,\n            name: entry.scores.map(d => d.from).join`, `,\n            entry,\n        }));\n\n    const publicStr = task.public ? ' {dc}[PUBLIC]{/}' : '';\n    const hasPublicScore = scores[0] && scores[0].name === '##jsgolf';\n    const fmtRank = ({ entry: { position, rank }}, index) => { \n        const value = showPosition ? position : rank;\n        return hasPublicScore ? value - 1 : value;\n    }\n\n    print(leaderboard({\n        scores,\n        title: `Leaderboard - ${IRC.colors.nick(task.displayName, !1)}${publicStr}`,\n        reverse: true,\n        limit: showAll ? Infinity : 5,\n        fmtRank,\n    }));\n} else {\n    const userScores = [];\n    const user = type.toLowerCase();\n    taskList.map(key => getLeaderboard(key))\n        .forEach((board, i) => {\n            const key = taskListDisplay[i];\n            const wr = board.length ? board[0].bytes : 0;\n            board.forEach(entry => {\n                if (entry.scores.find(score => score.from.toLowerCase() === user)) {\n                    entry.wrRatio = entry.bytes / wr;\n                    userScores.push([key, entry]);\n                }\n            });\n        });\n\n    if (!userScores.length) {\n        throw 'no task by this name / no scores for this user'\n    }\n\n    const avgRank =  +(userScores.reduce((a, b) => a + b[1].rank, 0) / userScores.length).toFixed(2);\n    const avgPos = +(userScores.reduce((a, b) => a + b[1].position, 0) / userScores.length).toFixed(2);\n    const baseRatio = +(userScores.reduce((a, b) => a + b[1].wrRatio, 0) / userScores.length).toFixed(2);\n    const wrs = userScores.filter(d => d[1].rank === 1).length;\n    const scores = userScores.map(([taskName, { bytes, position, rank }]) => {\n        return `${IRC.colors.nick(taskName, false)}:{y}${bytes}{/}:{g}${rank}{/}:{dg}${position}{/}`;\n    }).join` `;\n    const desc = '{bo}task{/}:{y}score{/}:{g}rank{/}:{dg}position{/}';\n    const wrString = wrs ? ` {bo}World Records:{/} {dc}${wrs}{/}` : '';\n    print(`{bo}Tasks Complete:{/} {dc}${userScores.length}/${taskList.length}{/} {bo}Avg WR Ratio:{/} {dc}${baseRatio}{/} {bo}Avg Rank:{/} {dc}${avgRank}{/} {bo}Avg Position:{/} {dc}${avgPos}{/}${wrString}  (${desc})`);\n    print(scores);\n}",
    "locked": false,
    "starred": false
}