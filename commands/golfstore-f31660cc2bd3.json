{
    "locked": false,
    "starred": false,
    "name": "golf.store",
    "command": "// changelog\n//\n// refactored everything\n// added public tasks\n// added solution histories\n// arranged scores by timestamps - earlier user come first\n// made tasks case sensitive\n// lots more information in user's golf.scores\n// take 'position' modifier for alternative task scores\n// added world record annotation\n// force private tasks to take place in PM\n//\n//\n// golf.task\n// golf.submit\n// golf.scores\n// golf.tasks\n// golf.store\n\n    // solution history\n// golf.solution \n// golf.test\n// golf\n//\n// remove demo \n\n\n// store.load\nconst save = (key, data) => store.set(key, JSON.stringify(data));\nconst load = (key, init = {}) => {\n    const data = store.get(key);\n    return typeof data === 'undefined' ? init : JSON.parse(data);\n};\n\n// migrate\n// ['logo','ROT13','hex2rgb','quine','cross','wordpath','numberWords','pyramid','triangle','miniJSON','blockmatrix','prime','pi','vowelratio','helloworld','longstring','RPN','boggle','romanNumerals','romanNumerals2','toMorse','shortestPath','polyfill','mostVisited','chunk','toString','gradient','ACR-numbers','brainfuck'].forEach(d => {\n//     const [key, item] = [d, IRC.require('module.loadObject')(`scores-${d}`)[0]];\n//     Object.keys(item).forEach(k => { item[k].history = []; });\n//     save('task-' + key.toLowerCase(), item);\n// });\n\n// save('task-demo', {});\n\n// scores: [{ bytes, solution, timestamp }]\n\nfunction getScores(task) {\n    return load(`task-${task.toLowerCase()}`);\n}\n\nfunction setScores(task, obj) {\n    return save(`task-${task.toLowerCase()}`, obj);\n}\n\nfunction getLeaderboard(name) {\n    const list = Object.entries(getScores(name))\n        .map(([key, value]) => ({ from: key, ...value }));\n    list.sort((a, b) => a.bytes - b.bytes);\n    const grouped = [/*{ bytes, scores, position, rank }*/];\n    list.forEach(score => {\n        const exists = grouped.find(d => d.bytes === score.bytes)\n        if (exists) {\n            exists.scores.push(score)\n        } else {\n            grouped.push({ bytes: score.bytes, scores: [score] });\n        }\n    });\n    // arrange by timestamps\n    let position = 1;\n    grouped.forEach((group, i) => {\n        group.scores.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))\n        group.rank = i + 1;\n        group.position = position;\n        position += group.scores.length;\n    })\n    return grouped;\n}\n\nmodule.exports = {\n    getLeaderboard,\n    getScores,\n    setScores,\n};"
}