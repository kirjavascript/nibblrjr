{
    "name": "golf.tasks",
    "command": "const { stringify, isEqual, assertType, assertEq, assertCall, removeEval } = IRC.require('golf.util');\n\nconst tasks = {\n    'logo': { // key must be lowercase\n        info: '{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1JLF') + ' (the string is trimmed before comparison)',\n        public: true,\n        test: (solution) => {\n            const jsgolf = `#############################################\n#                                           #\n#      #  ####   ####   ####  #      ###### #\n#      # #      #    # #    # #      #      #\n#      #  ####  #      #    # #      #####  #\n#      #      # #  ### #    # #      #      #\n# #    # #    # #    # #    # #      #      #\n#  ####   ####   ####   ####  ###### #      #\n#                                           #\n#############################################`;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result.trim(), jsgolf);\n            });\n        },\n    },\n    'rot13': {\n        displayName: 'ROT13',\n        info: '{bo}Write a function that returns a ROT13 ciphered version of its input string.\\nYour solution needs to cover the characters; abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('NOPQWXYZabcdefghijklmABCGHIJKLMnopqrstuvwRSTUVDEFxyz'), 'ABCDJKLMnopqrstuvwxyzNOPTUVWXYZabcdefghijEFGHIQRSklm');\n                assertEq(result('HKLMUVDEefgpyzbcdTtuvnoXYNOPQWhijklmqrsZaxABCGwRSIJF'), 'UXYZHIQRrstclmopqGghiabKLABCDJuvwxyzdefMnkNOPTjEFVWS');\n            });\n        },\n    },\n    'hex2rgb': {\n        displayName: 'hex2RGB',\n        info: '{bo}Write a function to convert a hex color ({o}#FFFFFF{/}{bo}) or ({o}#FFF{/}{bo}) to rgb ({dc}rgb(255,255,255){/}{bo})',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('#B04B4B'), 'rgb(176,75,75)'); \n                assertEq(result('#7E88E6'), 'rgb(126,136,230)'); \n                assertEq(result('#1FA11F'), 'rgb(31,161,31)'); \n                assertEq(result('#123'), 'rgb(17,34,51)'); \n                assertEq(result('#7FFFD4'), 'rgb(127,255,212)');\n                assertEq(result('#B0E0E6'), 'rgb(176,224,230)');\n                assertEq(result('#5F9EA0'), 'rgb(95,158,160)');\n                assertEq(result('#4682B4'), 'rgb(70,130,180)');\n                assertEq(result('#6495ED'), 'rgb(100,149,237)');\n                assertEq(result('#00BFFF'), 'rgb(0,191,255)');\n                assertEq(result('#1E90FF'), 'rgb(30,144,255)');\n                assertEq(result('#ADD8E6'), 'rgb(173,216,230)');\n                assertEq(result('#87CEEB'), 'rgb(135,206,235)');\n                assertEq(result('#87CEFA'), 'rgb(135,206,250)');\n                assertEq(result('#666'), 'rgb(102,102,102)');\n                assertEq(result('#F00'), 'rgb(255,0,0)');\n            });\n        },\n    },\n    'quine': {\n        info: '{bo}Write a quine',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                if (result.length < 1) throw new Error('program length must be non-zero');\n                if (result != solution) throw new Error('output doesn\\'t match source');\n            });\n        },\n    }, \n    'cross': {\n        info: '{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1FZt') + ' (the string is trimmed before comparison)',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const art = `#......#\\n.#....#.\\n..#..#..\\n...##...\\n...##...\\n..#..#..\\n.#....#.\\n#......#`;\n                assertType(result, 'string');\n                assertEq(result.trim(), art);\n            });\n        },\n    },\n    'wordpath': {\n        info: `{bo}Given two single words, return a word path ({y}array{/}{bo}) from word a to word b where the word changes one character at every step. All steps have to be valid words in the dictionary at {p}global.words{/}{bo}, and all words will be of length 4. for example: ('more', 'fact') => ['more', 'fore', 'fort', 'fart', 'fact']. the full wordlist is here: https://paste.rs/o0j`,\n        test: (solution) => {\n            const words = Object.freeze('abed,abid,ahed,ails,ains,aked,albe,albs,aloe,alow,amid,anew,arbs,asar,aunt,axed,axel,axil,bait,bale,balk,bane,bank,bare,barn,base,bays,bazz,beal,bene,bent,best,bile,bima,bine,bint,bobs,boep,bogs,bois,bola,bolo,book,boon,boos,bork,boss,bota,boun,brag,brap,brig,bris,buik,bums,bunt,burk,busk,buss,caca,cain,call,cann,cans,cavy,cill,clow,cobs,coca,coda,come,coms,cone,coof,coop,coos,crab,crag,crow,dans,dead,deaf,dear,deaw,deer,diol,dire,dirl,disa,dish,diva,dobe,doby,dore,dorr,dosh,dote,doun,doup,dour,duck,dush,eans,ease,eats,elks,elts,emes,emic,emit,enew,epic,eres,erns,ests,eugh,exes,exit,eyra,fags,fall,farl,fell,fibs,figs,fill,filo,fils,flow,frig,fris,friz,fros,frow,fuck,fums,gamp,garb,gars,gaus,gays,gien,gies,gips,glow,goaf,goal,goof,goon,goos,gors,gris,gush,gust,gymp,hahs,hail,hare,hark,hauf,haul,haze,head,hear,heat,hell,hent,herd,hery,high,hish,hons,hops,hork,houf,hubs,hups,iris,iwis,kail,kais,kans,keas,kens,khud,kobs,ksar,kuru,lace,laze,lead,lean,lear,leas,lehr,lept,lice,life,limy,lins,liny,lone,loof,loos,lote,lush,lyne,lynx,lyra,maar,maas,mala,malt,mats,meal,meck,mere,mese,mesh,mick,mini,miny,mosh,muni,murk,mush,muti,nain,nams,nats,naze,nigh,oboe,obol,ohed,oink,ordo,ords,oups,past,peck,pips,plot,plow,pock,poep,poke,pone,pons,poon,poop,poot,post,pugh,push,rahs,rait,rare,rase,raze,razz,read,rean,redd,reno,reny,riff,rifs,rima,rimu,roke,rota,rurp,ruru,rusk,sall,salp,salt,samp,scry,sept,sext,shen,shew,shim,shin,ship,shit,shop,sigh,sigs,sile,silo,sinh,sink,skeg,sken,slit,soda,sogs,solo,soop,spec,spic,spry,sten,swam,swan,swim,tala,tehr,tene,thin,thud,tiff,toff,tops,umph,umpy,vale,viae,vine,vire,wale,waly,wast,wavy,waxy,wink,wins,wons,yaar,yarn,yelm,yelp,yest,yock,ywis'.split`,`);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                const _result = result;\n                result = (...args) => {\n                    global.words = words\n                    return _result(...args);\n                };\n\n                const diff = (a, b) => {\n                    let count=0;\n                    for(let i=0; i< a.length; i++) {\n                        if( a[i] !== b[i]) count++\n                    }\n                    return count\n                }\n\n                function assertPath(start, end) {\n                    const wordpath = result(start, end);\n                    if (wordpath.length < 2) {\n                        throw 'word path is not long enough'\n                    }\n                    if (wordpath[0] !== start) {\n                        throw `first word in array is not ${start}`\n                    }\n                    if (wordpath[wordpath.length-1] !== end) {\n                        throw `last word in array is not ${end}`\n                    }\n\n                    if( wordpath.map( w => words.includes( w)).filter( x=>x===false).length>0) {\n                        throw ( 'some of those words are probably not real words')\n                    }\n                    for(let i=0; i< wordpath.length-1; i++) {\n                        if(diff( wordpath[i], wordpath[i+1])!==1) {\n                            throw ( wordpath[i] + ' and ' + wordpath[i+1] + ' either differ too much or are the same')\n                        }\n                    }\n                }\n\n                [[\"swim\", \"shim\"], [\"ohed\", \"amid\"], [\"pugh\", \"dosh\"], [\"coof\", \"cobs\"], [\"goal\", \"loof\"], [\"khud\", \"khud\"], [\"pons\", \"roke\"], [\"eugh\", \"pugh\"], [\"loos\", \"garb\"], [\"dans\", \"nain\"], [\"flow\", \"crow\"], [\"lote\", \"dour\"], [\"yelm\", \"yelp\"], [\"viae\", \"bint\"], [\"rota\", \"solo\"], [\"soop\", \"soop\"], [\"boon\", \"doup\"], [\"lush\", \"gust\"], [\"friz\", \"brap\"], [\"oboe\", \"obol\"], [\"anew\", \"enew\"], [\"lyra\", \"eyra\"], [\"poon\", \"wast\"], [\"yarn\", \"ease\"], [\"hery\", \"redd\"], [\"elks\", \"nams\"], [\"boep\", \"shop\"], [\"deaw\", \"deer\"], [\"goon\", \"murk\"], [\"lead\", \"rean\"], [\"oink\", \"wons\"], [\"rait\", \"bait\"], [\"swan\", \"swim\"], [\"rahs\", \"hahs\"], [\"life\", \"laze\"], [\"waxy\", \"vale\"], [\"gien\", \"pips\"], [\"umpy\", \"umph\"], [\"coos\", \"coos\"], [\"meal\", \"meal\"], [\"ests\", \"kens\"], [\"lept\", \"sext\"], [\"fags\", \"nigh\"], [\"exes\", \"emes\"], [\"yaar\", \"mats\"], [\"buss\", \"fums\"], [\"shin\", \"thin\"], [\"peck\", \"yock\"], [\"high\", \"diva\"], [\"spec\", \"exit\"], [\"hons\", \"tops\"], [\"meck\", \"mick\"], [\"salt\", \"tala\"], [\"tene\", \"bare\"], [\"rifs\", \"toff\"], [\"ywis\", \"bois\"], [\"oups\", \"hubs\"], [\"rare\", \"rase\"], [\"hent\", \"deaf\"], [\"alow\", \"arbs\"], [\"hear\", \"keas\"], [\"skeg\", \"sten\"], [\"waly\", \"cavy\"], [\"bobs\", \"sogs\"], [\"diol\", \"vire\"], [\"boss\", \"kobs\"], [\"naze\", \"hork\"], [\"gymp\", \"sall\"], [\"crag\", \"crab\"], [\"spry\", \"scry\"], [\"reny\", \"reno\"], [\"bazz\", \"raze\"], [\"gaus\", \"bays\"], [\"ordo\", \"ords\"], [\"glow\", \"plot\"], [\"duck\", \"fuck\"], [\"muni\", \"muti\"], [\"mere\", \"mosh\"], [\"asar\", \"ksar\"], [\"bank\", \"sile\"], [\"houf\", \"kais\"], [\"ails\", \"lins\"], [\"axil\", \"aked\"], [\"hell\", \"farl\"], [\"slit\", \"ship\"], [\"frow\", \"gris\"], [\"rurp\", \"kuru\"], [\"buik\", \"rusk\"], [\"tehr\", \"lear\"], [\"doby\", \"doby\"], [\"lynx\", \"coms\"], [\"soda\", \"caca\"], [\"yest\", \"aunt\"], [\"limy\", \"muni\"], [\"bima\", \"rimu\"], [\"sinh\", \"sink\"], [\"erns\", \"eres\"], [\"shen\", \"shew\"], [\"fibs\", \"silo\"], [\"push\", \"mush\"], [\"fibs\", \"call\"]].forEach(([a,b]) => {\n                        assertPath(a, b)\n                        assertPath(b, a)\n                    });\n\n            });\n        }\n\n\n\n    },\n    'numberwords': {\n        displayName: 'numberWords',\n        info: '{bo}Write a function that takes a number, and returns a space-delimited word representation of that number. \\nFor example, given 120 as input you would return \\'one two zero\\'  {/}',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                if (\n                    result(123) !== 'one two three' ||\n                    result(90807) !== 'nine zero eight zero seven' ||\n                    result(564) !== 'five six four' ||\n                    result(120349) !== 'one two zero three four nine'\n                ) throw new Error('received invalid result');\n            });\n        }\n    },\n    'pyramid': {\n          info: '{bo}Given a positive integer, draw an ASCII pyramid with as many rows. For example, given a 2: \\n /\\\\\\n/__\\\\\\n',\n          test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 1, '/\\\\\\n' ],\n                    [3, '  /\\\\\\n /  \\\\\\n/____\\\\\\n'],\n                    [8, '       /\\\\\\n      /  \\\\\\n     /    \\\\\\n    /      \\\\\\n   /        \\\\\\n  /          \\\\\\n /            \\\\\\n/______________\\\\\\n'],\n                    [32, '                               /\\\\\\n                              /  \\\\\\n                             /    \\\\\\n                            /      \\\\\\n                           /        \\\\\\n                          /          \\\\\\n                         /            \\\\\\n                        /              \\\\\\n                       /                \\\\\\n                      /                  \\\\\\n                     /                    \\\\\\n                    /                      \\\\\\n                   /                        \\\\\\n                  /                          \\\\\\n                 /                            \\\\\\n                /                              \\\\\\n               /                                \\\\\\n              /                                  \\\\\\n             /                                    \\\\\\n            /                                      \\\\\\n           /                                        \\\\\\n          /                                          \\\\\\n         /                                            \\\\\\n        /                                              \\\\\\n       /                                                \\\\\\n      /                                                  \\\\\\n     /                                                    \\\\\\n    /                                                      \\\\\\n   /                                                        \\\\\\n  /                                                          \\\\\\n /                                                            \\\\\\n/______________________________________________________________\\\\\\n'],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input), output);\n                });\n            });\n          }\n    },\n    'triangle': {\n        info: '{bo}Provide a function that returns the nth row of pascal\\'s triangle as an array of numbers',\n        test: (solution) => {\n            const { pascal } = require('pascal-triangle');\n            const triangle = pascal(30);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                for(let i = 1; i < 30; i++) {\n                    assertCall(result, triangle[i-1], i);\n                }\n            });\n        },\n    },\n    'minijson': {\n        displayName: 'miniJSON',\n        info: '{bo}Create a JSON parser that handles {y}strings{/}{bo}, {y}numbers{/}{bo}, and {y}arrays{/}{bo}. (You cannot use {dc}eval{/}{bo} or the {dc}JSON{/}{bo} object)',\n        test: (solution) => {\n\n            const tests = [` 123\n                `,` [1, 2, 3]\n                `,` [[12, 2, [3]], []]\n                `,` \"hello world\"\n                `,` \"hello \\\\\" world\"\n                `,` 123e5\n                `,` [\"bork\", 123]\n                `,` \"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"''''\"\n                `,` [123, \"[123, \", 123]\n                `,` [123, [], [], [], [123],[]   ,   []]\n                `,` [1e2,3e4,     999]\n                `,` [1,2,3, [\"extra stuff\"]]\n                `,` [\"\",1,[\"[[]]\"],2,[[],[[[],\"][\",[3.14]]],\"][\"]]\n                `,` \"\"\n                `,` -14e-3\n                `,` 1.11e+113\n                `,` \" \"\n                `,` \"\\\\\\\\\"\n                `,` \"\\\\\\\\\\\\\\\"\"\n                `,` \"\\\\\\\\\\\\\\\\\"\n                `,` [\"these\", [\"are\", [\"strings\", [\"inside\", [\"arrays\"]]]]]\n                `,` [[[[],[[[31337]]]]],[]]\n                `,` 1e10\n                `,` 0\n                `,` [[\"0\", \"[0,[0]\"], [0]]\n            `]\n\n            const cases = tests.map(test => [test, JSON.parse(test)]);\n            const trueJSON = global.JSON;\n            delete global.JSON;\n            const golfEval = IRC.require('golf.eval');\n            const restoreEval = removeEval();\n            let error;\n            try {\n                golfEval(solution, result => {\n                    assertType(result, 'function');\n                    cases.forEach(([input, expected]) => {\n                        assertCall(result, expected, input);\n                    });\n                });\n            } catch (e) {\n                error = e;\n            }\n\n            // cleanup\n            restoreEval();\n            global.JSON = trueJSON;\n\n            // rethrow any collected errors\n            if (error) {\n                throw error;\n            }\n        },\n    },\n    'blockmatrix': {\n        info: '{bo}Given a binary matrix, construct a string using block characters (▖ ▗ ▘ ▙ ▚ ▛ ▜ ▝ ▞ ▟ ▀ ▄ █ ▌ ▐). 1char = 4 pixels',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertType(result([[0,0], [0,0]]), 'string');\n                [\n                    [[[0,1], [1,0]], \"▞\"],\n                    [[[1,1,1,0],[0,0,1,1]], \"▀▙\"],\n                    [[[1,1],[1,1]], \"█\"],\n                    [[[1,1],[0,1]], \"▜\"],\n                    [[[1,1,0,1],[1,1,1,1]], \"█▟\"],\n                    [[[0,1,0,1],[0,1,0,1]], \"▐▐\"],\n                    [[[1,0],[1,0]], \"▌\"],\n                    [[[1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0]], \"▛▖▞▖▞▖▛▖\\n▛ ▚▘▚▘▛ \"],\n                    [[[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0]], \" ▄▖▗▄ \\n▐████▌\\n ▜██▛ \\n  ▜▛  \"],\n                    [[[1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1],[0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1],[1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[0,1,0,1,0,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,0,0],[0,1,0,1,0,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1]], \"▀▘▘▘▀▝▞▖▗▚▝ ▐ ▞ \\n▗▘▖▚  ▚▝▝ ▚▘▌▞▗▐\\n▜▚▝▞▛██▛▀▖▝▖▝▐ ▞\\n▐▗▚▝▟▟▞▞▐▚▜▜▜▝▞▗\"],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input).replace(/\\n+$/,''), output);\n                })\n            });\n        },\n\n    },\n    'prime': {\n        info: `{bo}Write an script that evaluates to an array containing all prime numbers below 1000 in order`,\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'object');\n                assertEq(result, [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]);\n            });\n        },\n    },\n    'pi': {\n        info: `{bo}Write a script that evaluates to a string containing the the first 100 decimal places of pi ({/}{dg}'3.14159 ...'{/}{bo})`,\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result, '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679');\n            });\n        },\n    },\n    'vowelratio': {\n        info: '{bo}Calculate the simplified ratio of vowels [aeiou] to consonants in a given string. For example, {/}{dc}cake{/}{bo} would give {/}{dg}\"1:1\"',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 'cake', '1:1' ],\n                    [ 'no', '1:1' ],\n                    [ 'x', '0:1' ],\n                    [ 'oaie', '1:0' ],\n                    [ 'xx', '0:1' ],\n                    [ 'golf', '1:3' ],\n                    [ 'figuratively', '5:7' ],\n                    [ '1e5', '1:0'],\n                    [ '0xff', '0:1'],\n                    [ '0xf', '0:1'],\n                    [ '1e9999', '1:0' ],\n                    [ '1.1e0', '1:0' ],\n                    [ 'the quick brown fox jumped over the lazy dog.', '1:2' ],\n                    [ 'lololol', '3:4' ],\n                    [ 'mozilla firefox™', '3:4' ],\n                    [ 'kirjava was here 2019', '3:4' ],\n                    [ 'The C/++ Programming Language', '8:15' ],\n                    [ 'bleh bleh bleh', '1:3' ],\n                    [ 'how are you enjoying the task', '5:7' ],\n                    [ 'adding more test cases', '7:12' ],\n                    [ \"I'm blue da ba dee da ba daa, da ba dee, da be daa\", '19:15' ],\n                    [ 'rustlang', '1:3' ],\n                    [ 'powerwank', '1:2' ],\n                    [ 'sega genesis', '5:6' ],\n                    [ 'chip-8', '1:3' ],\n                    [ 'oh wait these dont actually have to be real words', '2:3' ],\n                    [ 'saduhfgaiulewdfahlusdfghuasdgfa', '11:20' ],\n                    [ 'asdajasdjflkas jasldalkhjwjw', '2:7' ],\n                    [ 'as dkhnasbd anl dwk alknbwd aw', '1:4' ],\n                    [ 'aksdjalksjdaklsasdca gjokdfiogboi', '5:11' ],\n                    [ 'isdfvosoiu hg sdknlfsnkjflknsd nk', '1:5' ],\n                ].forEach(([input, expected]) => {\n                    assertCall(result, expected, input);\n                });\n            });\n        },\n    },\n    'helloworld': {\n        info: '{bo}Write a script that evaluates to the string {dg}\"Hello World\"{/}{bo}. You cannot use {y}quotes{/}{bo}, {y}slashes{/}{bo} or {y}round brackets{/}{bo}',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`\\/\\\\\\(\\)]/g, d => `{r}${d}{/}`);\n                if (/[\"'`\\/\\\\\\(\\)]/.test(solution)) {\n                    throw new Error(`your solution contains disallowed characters: ${highlighted}`);\n                }\n                assertEq(result, 'Hello World');\n            });\n        },\n    },\n    'longstring': {\n        info: '{bo}Write a script that evaluates to a string of length 17707. You cannot use {y}quote{/}{bo} or {y}number{/}{bo} characters',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`]/g, d => `{r}${d}{/}`).replace(/\\d+/g, d => `{r}${d}{/}`);\n                if (/[\"'`]/.test(solution) && /\\d/.test(solution)) {\n                    throw new Error(`your solution contains quote and number characters: ${highlighted}`);\n                }\n                if (/[\"'`]/.test(solution)) {\n                    throw new Error(`your solution contains quote characters: ${highlighted}`);\n                }\n                if (/\\d/.test(solution)) {\n                    throw new Error(`your solution contains number characters: ${highlighted}`);\n                }\n\n                if (result.length !== 17707) {\n                    throw new Error(`expected length {dc}17707{/} got {o}${result.length}{/}`);\n                }\n            });\n        },\n    },\n    'rpn': {\n        displayName: 'RPN',\n        info: '{bo}Write a function that evaluates reverse polish notation',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                // https://www.mathblog.dk/tools/infix-postfix-converter/\n                // https://lab.miguelmota.com/postfix-calculator/demo/\n                assertEq(result('15 7 1 1 + - / 3 * 2 1 1 + + -'), 5);\n                assertEq(result('3 3 5 3 * / + 10 +'), 13.2);\n                assertEq(result('3 3 3 / * 1239 +'), 1242);\n                assertEq(result('3 3 / 3 3 / * 1239 +'), 1240);\n                assertEq(result('31337 187123 * 99 -234875 4 / + +'), 5863814831.25);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 1234 * +'), 3234837776359);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 123 * +'), 322435207965);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 57);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 4 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 58);\n                assertEq(result('1 3 * 10 + 0 +'), 13);\n                assertEq(result('-1 -1 -'), 0);\n                assertEq(result('-1 -10 -'), 9);\n                assertEq(result('1'), 1);\n            });\n        },\n    },\n    boggle: {\n        info: '{bo}Given a string of 16 characters and a word, return true if that word can be made using a 4x4 Boggle grid made from the 16 characters (4 x 4 rows).',\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                const assert = (grid, word, res) => { \n                    assertEq(result(grid, word), res);\n                };\n\n                assert( 'bsoitlshnreolfis', 'shoes', true);\n                assert( 'bsoitlshnreolfis', 'heirs', true);\n                assert( 'bsoitlshnreolfis', 'flesh', false);\n\n                assert( 'piohdmleosxesent', 'sextet', false);\n                assert( 'piohdmleosxesent', 'doses', true);\n                assert( 'piohdmleosxesent', 'dome', false);\n\n                assert( 'iosietpregiediah', 'poster', false);\n                assert( 'iosietpregiediah', 'baboon', false);\n                assert( 'iosietpregiediah', 'spirited', true);\n\n                assert( 'enesddssnbmeaint', 'absentmindedness', true);\n                assert( 'gbaiessxtsseazsl', 'assesses', true);\n                assert( 'ioioiooioioioioi', 'ioioioioioioioio', true);\n                assert( 'saibissaesseasaa', 'assasssassa', false);\n                assert( \"hasezxclrtolpoit\", \"hello\", false);\n                assert('..WORD..........', 'WORD', false);\n                assert('zxcvasdfqwerasdf', 'dewax', true);\n            });\n        }\n    },\n    'romannumerals': {\n        displayName: 'romanNumerals',\n        public: true,\n        info: `{bo}Write a function that converts a positive integer to roman numerals`,\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(num), str);\n                });\n            });\n        },\n    },\n    'romannumerals2': {\n        displayName: 'romanNumerals2',\n        public: true,\n        info: `{bo}Write a function that converts a roman numeral into an integer`,\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(str), num);\n                });\n            });\n        },\n    },\n    'tomorse': {\n        displayName: 'toMorse',\n        info: `{bo}Write a function that converts text to morse code. You need one space between letters, and three between words`,\n        public: true,\n        test: (solution) => {\n            const lookup = { '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', ' ': ' ' };\n\n            const solve = (s) => [...s].map(l => lookup[l.toLowerCase()]).join` `;\n\n            const tests = [ 'bum', '12345', 'caSh MoNey', 'hello world', '1e999 is infinity', 'pooooop Abcdefghijklmnopqrstuvwxyz 0 1234 5 6 7 8 81012', '1337 hax m8', 'futurama', 'nibblrjr', 'golf and more golf', 'sigh test cases', 'and more and more', 'and then even some more', 'it just has to keep going until its too many for someone to cheat with ' ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach((str) => {\n                    assertCall(result, solve(str), str)\n                });\n            });\n        },\n    },\n    'shortestpath': {\n        displayName: 'shortestPath',\n        info: `{bo}Write a function to find the shortest path in a graph. Vertices are named with single letter, case sensitive. Input is given as edge array, start vertex, destination vertex, i.e., ['AB1',...], 'A', 'B'. 'AB1' means that edge between A and B vertices is of length 1. Output should be an array of path length and path, i.e., [1,'AB']. If no path is available, return [Infinity].`,\n        test: (solution) => {\n            const graphs = [\n                [[\"AI2\",\"AH47\",\"AG53\",\"AE75\",\"CD39\",\"CE84\",\"DG69\",\"DE28\",\"EG17\",\"FI29\",\"FD46\",\"FH44\",\"FB46\",\"GH54\",\"HB95\",\"HC4\",\"IG94\",\"IC14\",\"IB9\"],\"G\",\"B\"],\n                [[\"AM23\",\"Ba87\",\"BH84\",\"BD6\",\"BA48\",\"CF30\",\"CM51\",\"CH43\",\"CG29\",\"DH63\",\"DA61\",\"Da60\",\"DI76\",\"DG27\",\"EF73\",\"EM77\",\"EI31\",\"FG73\",\"GL21\",\"GE67\",\"GM25\",\"HA65\",\"IF65\",\"IM54\",\"IG42\",\"JD34\",\"JG23\",\"LE19\",\"LD29\",\"LC83\",\"LA38\",\"La76\",\"LM73\",\"MB66\",\"MD63\"],\"K\",\"I\"],\n                [[\"AC22\",\"AF65\",\"CG2\",\"CB38\",\"EG64\",\"EB48\",\"EA24\",\"GB62\",\"GD6\"],\"C\",\"F\"],\n                [[\"BC7\",\"BD46\",\"CA12\",\"CH77\",\"DJ31\",\"DA50\",\"EJ63\",\"FA49\",\"HJ73\",\"HK30\",\"HA31\",\"IK81\",\"IG81\",\"IA17\",\"KA78\",\"KD54\",\"KC80\"],\"E\",\"H\"],\n                [[\"BA74\",\"BC41\",\"DA74\",\"DC51\",\"EC42\",\"ED34\"],\"E\",\"A\"],\n                [[\"AL5\",\"AB61\",\"BJ12\",\"BF62\",\"CD45\",\"DH43\",\"DA56\",\"EH75\",\"EF92\",\"EJ7\",\"FJ7\",\"FM16\",\"FA68\",\"GI15\",\"GM13\",\"HL78\",\"Ia77\",\"IC68\",\"IM51\",\"JC17\",\"KD4\",\"KG68\",\"KE54\",\"LB18\",\"aL20\"],\"A\",\"L\"],\n                [[\"AH61\",\"AD10\",\"AC29\",\"AG27\",\"BC53\",\"BE32\",\"CI95\",\"CD3\",\"DE20\",\"DG80\",\"EK92\",\"HI42\",\"HJ97\"],\"J\",\"E\"],\n                [[\"AL91\",\"AK98\",\"AI15\",\"BD60\",\"BA46\",\"BG12\",\"BH31\",\"BE4\",\"CB96\",\"CJ13\",\"DJ28\",\"DH35\",\"DC42\",\"FG16\",\"HF73\",\"HK46\",\"JB44\",\"JA55\",\"LE37\",\"LB34\",\"LJ39\"],\"F\",\"G\"],\n                [[\"AF12\",\"AC49\",\"AL78\",\"CI5\",\"CB76\",\"EG61\",\"FI9\",\"GF52\",\"GA20\",\"HE15\",\"HF94\",\"HM49\",\"IE37\",\"IK20\",\"JF8\",\"LH86\",\"LJ33\",\"LE38\",\"MI60\"],\"C\",\"I\"],\n                [[\"AE51\",\"AC27\",\"BF84\",\"BD51\",\"BE5\",\"BA6\",\"CB74\",\"DC63\",\"DF13\",\"EF59\",\"EC22\",\"FA84\"],\"F\",\"B\"],\n                [[\"AI2\",\"AH47\",\"AG53\",\"AE75\",\"CD39\",\"CE84\",\"DG69\",\"DE28\",\"EG17\",\"FI29\",\"FD46\",\"FH44\",\"FB46\",\"GH54\",\"HB95\",\"HC4\",\"IG94\",\"IC14\",\"IB9\"],\"E\",\"I\"],\n                [[\"AM23\",\"Ba87\",\"BH84\",\"BD6\",\"BA48\",\"CF30\",\"CM51\",\"CH43\",\"CG29\",\"DH63\",\"DA61\",\"Da60\",\"DI76\",\"DG27\",\"EF73\",\"EM77\",\"EI31\",\"FG73\",\"GL21\",\"GE67\",\"GM25\",\"HA65\",\"IF65\",\"IM54\",\"IG42\",\"JD34\",\"JG23\",\"LE19\",\"LD29\",\"LC83\",\"LA38\",\"La76\",\"LM73\",\"MB66\",\"MD63\"],\"a\",\"M\"],\n                [[\"AC22\",\"AF65\",\"CG2\",\"CB38\",\"EG64\",\"EB48\",\"EA24\",\"GB62\",\"GD6\"],\"A\",\"G\"],\n                [[\"BC7\",\"BD46\",\"CA12\",\"CH77\",\"DJ31\",\"DA50\",\"EJ63\",\"FA49\",\"HJ73\",\"HK30\",\"HA31\",\"IK81\",\"IG81\",\"IA17\",\"KA78\",\"KD54\",\"KC80\"],\"I\",\"C\"],\n                [[\"BA74\",\"BC41\",\"DA74\",\"DC51\",\"EC42\",\"ED34\"],\"D\",\"B\"],\n                [[\"AL5\",\"AB61\",\"BJ12\",\"BF62\",\"CD45\",\"DH43\",\"DA56\",\"EH75\",\"EF92\",\"EJ7\",\"FJ7\",\"FM16\",\"FA68\",\"GI15\",\"GM13\",\"HL78\",\"Ia77\",\"IC68\",\"IM51\",\"JC17\",\"KD4\",\"KG68\",\"KE54\",\"LB18\",\"aL20\"],\"C\",\"a\"],\n                [[\"AH61\",\"AD10\",\"AC29\",\"AG27\",\"BC53\",\"BE32\",\"CI95\",\"CD3\",\"DE20\",\"DG80\",\"EK92\",\"HI42\",\"HJ97\"],\"H\",\"C\"],\n                [[\"AL91\",\"AK98\",\"AI15\",\"BD60\",\"BA46\",\"BG12\",\"BH31\",\"BE4\",\"CB96\",\"CJ13\",\"DJ28\",\"DH35\",\"DC42\",\"FG16\",\"HF73\",\"HK46\",\"JB44\",\"JA55\",\"LE37\",\"LB34\",\"LJ39\"],\"B\",\"J\"],\n                [[\"AF12\",\"AC49\",\"AL78\",\"CI5\",\"CB76\",\"EG61\",\"FI9\",\"GF52\",\"GA20\",\"HE15\",\"HF94\",\"HM49\",\"IE37\",\"IK20\",\"JF8\",\"LH86\",\"LJ33\",\"LE38\",\"MI60\"],\"H\",\"A\"],\n                [[\"AE51\",\"AC27\",\"BF84\",\"BD51\",\"BE5\",\"BA6\",\"CB74\",\"DC63\",\"DF13\",\"EF59\",\"EC22\",\"FA84\"],\"B\",\"F\"],\n    [[\"ab1\", \"bc1\", \"cu1\", \"uv1\", \"wx1\"], \"a\",\"x\"],\n    [[\"au1\", \"bv12\", \"cw3\", \"dx17\"], \"a\",\"x\"], \n            ];\n\n            const results = [ [64,[\"GAIB\"]], [Infinity], [87,[\"CAF\"]], [136,[\"EJH\"]], [108,[\"EDA\"]], [5,[\"AL\"]], [188,[\"JHADE\"]], [16,[\"FG\"]], [5,[\"CI\"]], [64,[\"FDB\",\"FEB\"]], [72,[\"EGAI\"]], [112,[\"aDGM\"]], [24,[\"ACG\"]], [29,[\"IAC\"]], [92,[\"DCB\"]], [67,[\"CJBLa\"]], [74,[\"HADC\"]], [44,[\"BJ\"]], [73,[\"HEIFA\"]], [64,[\"BDF\",\"BEF\"]], [Infinity], [Infinity] ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                graphs.map((args, i) => {\n                    // fn is user submitted function\n                    const data = result(...args);\n                    if (!Array.isArray(data)) {\n                        throw new Error(`expected an {y}array{/} as the return type`);\n                    }\n                    const [rLength, rPath] = data;\n                    const [length, path] = results[i];\n                    if (length !== rLength) {\n                        throw new Error(`expected length {dc}${length}{/} got {o}${rLength}{/}`);\n                    }\n                    if (length !== Infinity && !path.includes(rPath)) {\n                        throw new Error(`path incorrect: expected {o}${path.join` or `}{/}`);\n                    }\n                });\n            });\n        },\n    },\n    'polyfill': {\n        info: `{bo}Polyfill Array.prototype.sort`,\n        test: (solution) => {\n            const tests = [\n                [[...'hello world'], undefined],\n                [_.shuffle(_.range(10, 20)), (a, b) => b - a], \n                [_.shuffle(_.range(10, 20)), (a, b) => a - b], \n                [_.shuffle(_.range(10, 20)).map(String), (a, b) => a - b], \n                [_.shuffle(_.range(10, 20)), undefined], \n                [_.shuffle(_.range(10, 20)).map(value => ({ value })), (a, b) => a.value - b.value], \n                [['March', 'Jan', 'Feb', 'Dec'], undefined],\n                [_.shuffle(_.range(-20, 20)), (a, b) => a - b], \n                [[...'🎱⛳️🎿🏂🎣🏊🏄🛀🏆🎽🎫🎭🎨🎪🎤🎧🎼🎹'], undefined],\n                [[], undefined],\n                [[1], undefined],\n                [[1, 5, 10], undefined],\n                [[2, 1, 1, 3, 1, 3, 3], undefined],\n                [[1n, 2, 1], undefined],\n                [[2, 1, 1n], undefined],\n                [[1, \"1\"], undefined],\n                [[\"1\", 1], undefined],\n                [[\"~\"], undefined],\n                [[...'zyxvw'], undefined],\n                // [[undefined, 1, undefined], () => {throw 'boop'}],\n                [[null,, undefined, 1, NaN, 1n, '1', {}, [], new Map], undefined],\n\n            ].map(([list, comp]) => [list, comp, _.cloneDeep(list).sort(comp)]);\n            const { sort } = Array.prototype;\n            delete Array.prototype.sort;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(Array.prototype.sort, 'function');\n\n                let caughtObj = false;\n                let caughtNull = false;\n                try { [].sort({}); } catch { caughtObj = true; }\n                try { [].sort(null); } catch { caughtNull = true; }\n\n                if (!caughtObj || !caughtNull) {\n                    throw new Error('must throw if the comparison is obj or null');\n                }\n                // const { enumerable } = Object.getOwnPropertyDescriptor(Array.prototype, 'sort');\n                // if (enumerable) {\n                //     throw new Error('Array.prototype.sort is meant to not be enumerable');\n                // }\n            });\n\n            tests.forEach(([_list, _comp, _expected]) => {\n                delete Array.prototype.sort;\n                IRC.require('golf.eval')(solution, result => {\n                    const expected = [..._expected];\n                    const list = [..._list];\n                    const original = [...list];\n                    const output = list.sort(_comp);\n                    if (output !== list) {\n                        throw new Error('must mutate original array');\n                    }\n                    if (!isEqual(expected, output)) {\n                        throw new Error(`expected {dc}${stringify(expected)}{/} got {o}${stringify(output)}{/}  (items: {dp}${stringify(original)}{/} comparison: {dp}${_comp}{/})`);\n                    }\n                });\n            });\n\n            //final check / cleanup\n            Array.prototype.sort = sort;\n            IRC.require('golf.eval')(solution, result => {\n                if (Array.prototype.sort !== sort) {\n                    throw new Error('replacing native prototypes is bad practise');\n                }\n            });\n        },\n    },\n    'mostvisited': {\n        displayName: 'mostVisited',\n        info: `{bo}https://gist.github.com/nderscore/6765d4f51267c93f700921729b32ac2e`,\n        test: (solution) => {\n            function mostVisited(path) {\n                let mostVisitedIndex = 0;\n                let mostVisitedTimes = 0;\n\n                let arr = new Array(Math.max(...path)).fill(0);\n\n                for (let index = 0; index <= path.length; index++) {\n                    let start = path[index];\n                    let next = path[index + 1];\n\n                    if (!next) {\n                        break;\n                    }\n\n                    if (next > start) {\n                        for (let i = start; i <= next; i++) {\n                            let arrIndex = i - 1;\n                            arr[arrIndex]++;\n                            let visitedValue = arr[arrIndex];\n                            if (\n                                visitedValue > mostVisitedTimes ||\n                                (visitedValue === mostVisitedTimes && arrIndex <= mostVisitedIndex)\n                            ) {\n                                mostVisitedTimes = visitedValue;\n                                mostVisitedIndex = arrIndex;\n                            }\n                        }\n                    } else {\n                        for (let i = next; i <= start; i++) {\n                            let arrIndex = i - 1;\n                            arr[arrIndex]++;\n                            let visitedValue = arr[arrIndex];\n                            if (\n                                visitedValue > mostVisitedTimes ||\n                                (visitedValue >= mostVisitedTimes && arrIndex <= mostVisitedIndex)\n                            ) {\n                                mostVisitedTimes = visitedValue;\n                                mostVisitedIndex = arrIndex;\n                            }\n                        }\n                    }\n                }\n                return mostVisitedIndex + 1;\n            }\n            const r=_=>(0|Math.random()*10)+1;\n            const t=_=>[...Array(r``+1)].map(r);\n\n            const tests = [\n                [1, 5, 3, 2],\n                [9, 3, 5, 6],\n                [1, 6, 5, 6, 4, 2, 1, 2],\n                [4, 9, 5, 9, 3],\n                [1,2,3,4,5,6,4, 11],\n                [4,5,3],\n                [6,5],\n                [ 4, 8, 2, 9, 3, 5, 9, 4, 5, 10, 5 ],\n                [ 7, 10, 10, 4, 10, 2, 4 ],\n                [1,5,3,5,2,4,1,4],\n                [2,10],\n                ...[...Array(300)].map(t),\n            ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach((arr) => {\n                    assertCall(result, mostVisited([...arr]), [...arr])\n                });\n            });\n            // https://gist.github.com/jurgenzz/42732a830bafccb3b8fb5b0805ddc6fb\n            // https://l.jurg.is/uploads/64d710152fb99888/\n        },\n    },\n    'chunk': {\n        info: `{bo}Write a function that given an {y}Array|String{/}{bo} and a {y}Number{/}{bo} creates an array of elements split into groups with the length specified. If it cannot be split evenly, the final chunk will be the remaining elements`,\n        test: (solution) => {\n            const tests = [\n                [_.shuffle(_.range(10, 20)), 2],\n                [_.shuffle(_.range(10, 20)), 4],\n                [[{}, [], {}, [], {}, [], {foo: 1}], 3],\n                ['js golf?', 1],\n                ['js golf?', Infinity],\n                [[undefined,undefined,undefined,undefined,undefined,undefined], 2],\n                [[undefined,undefined,undefined,undefined,undefined,undefined], 1],\n                [[false, 0, 0, 0], 1],\n                [[,,,,,,], 2],\n                [[], 9],\n                [[[[[]]], [[],[],[]], [[], []]], 2],\n                ['hello world', 2],\n                [String({}), 3],\n                [String(function(){}), 5],\n            ].map(([input, chunkBy]) => [input, chunkBy, _.chunk(input, chunkBy)]);\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach(([input, chunkBy, expected]) => {\n                    const data = typeof input === 'string' ? input : [...input];\n                    assertCall(result, expected, data, chunkBy)\n                });\n            });\n        },\n    },\n    'tostring': {\n        displayName: 'toString',\n        info: `{bo}Write an expression that evaluates to the string {g}toString{/}{bo}. You cannot use strings and the only sequence of alphanumerics in your solution must be {dc}\\`toString\\``,\n        test: (solution) => {\n\n            let invalid = 0;\n            const highlighted = solution.replace(/[0-9a-z]+/ig, a => {\n                const extra = a.replace(/toString/g, '');\n                if (extra.length) {\n                    invalid += 1;\n                    return `{r}${a.replace(/toString/g, '{/}toString{r}')}{/}`;\n                } else {\n                    return a;\n                }\n            });\n\n            if (/[\"'`]/.test(solution)) {\n                throw new Error(`your solution contains quote characters: ${solution.replace(/[\"'`]/g, d => `{r}${d}{/}`)}`);\n            }\n            if (invalid) {\n                throw new Error(`your solution contains alphanumeric characters that are not {dc}\\`toString\\`{/}: ${highlighted}`);\n            }\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result, 'toString');\n            });\n        },\n    },\n    'gradient': {\n        info: `{bo}Provide a scale between two hex colours, given a number of steps; {/}({dg}'#FF0000'{/}, {dg}'#00FF00'{/}, {o}3{/}) {p}=>{/} [{dg}\"#ff0000\"{/}, {dg}\"#7f7f00\"{/}, {dg}\"#00ff00\"{/}]`,\n        test: (solution) => {\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertCall(result, [\"#b04b4b\",\"#a35a71\",\"#976998\",\"#8a78bf\",\"#7e88e6\"], \"#B04B4B\",\"#7E88E6\",5);assertCall(result, [\"#1fa11f\",\"#2bac35\",\"#37b84c\",\"#43c462\",\"#4fd079\",\"#5bdb90\",\"#67e7a6\",\"#73f3bd\",\"#7fffd4\"], \"#1FA11F\",\"#7FFFD4\",9);assertCall(result, [\"#b0e0e6\",\"#a8dadf\",\"#a1d4d9\",\"#99ced2\",\"#92c8cc\",\"#8bc2c6\",\"#83bcbf\",\"#7cb6b9\",\"#75b0b3\",\"#6daaac\",\"#66a4a6\",\"#5f9ea0\"], \"#B0E0E6\",\"#5F9EA0\",12);assertCall(result, [\"#4682b4\",\"#4883b8\",\"#4b85bd\",\"#4d86c2\",\"#5088c7\",\"#5289cb\",\"#558bd0\",\"#578dd5\",\"#5a8eda\",\"#5c90de\",\"#5f91e3\",\"#6193e8\",\"#6495ed\"], \"#4682B4\",\"#6495ED\",13);assertCall(result, [\"#00bfff\",\"#05b7ff\",\"#0aafff\",\"#0fa7ff\",\"#149fff\",\"#1997ff\",\"#1e90ff\"], \"#00BFFF\",\"#1E90FF\",7);assertCall(result, [\"#add8e6\",\"#a0d4e7\",\"#93d1e9\",\"#87ceeb\"], \"#ADD8E6\",\"#87CEEB\",4);assertCall(result, [\"#87cefa\",\"#7abce7\",\"#6dabd5\",\"#609ac3\",\"#5389b1\",\"#46789e\",\"#39678c\",\"#2c567a\",\"#1f4568\",\"#123456\"], \"#87CEFA\",\"#123456\",10);\n\n                assertCall(result, [\"#000000\",\"#000000\"], \"#000000\",\"#000000\",2);\n            });\n        },\n    },\n    'acr-numbers': {\n        displayName: 'ACR-Numbers',\n        info: `{bo}ASCII Character Recognition - Numbers`,\n        test: (solution) => {\n\n            const ascii = [\n                `###  #  ### ### # # ### ### ### ### ### `,\n                `# # ##    #   # # # #   #     # # # # # `,\n                `# #  #  ###  ## ### ### ###   # ### ### `,\n                `# #  #  #     #   #   # # #   # # #   # `,\n                `### ### ### ###   # ### ###   # ### ### `,\n            ];\n            const chars = '0123456789'\n            const groups = ascii.map(d=>d.match(/.{4}/g))\n\n            function getArt(str) {\n                return groups.map((group, i) => {\n                    return [...str].map(d => {\n                        return group[chars.indexOf(d)]\n                    }).join``\n                }).join`\\n`\n            }\n            const tests = [\n                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n                '01',\n                '123',\n                '321',\n                '123456789',\n                '2348576234687',\n                '213234',\n                '23423',\n                '9082759682379305',\n                '3465',\n                '6534476',\n            ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach(test => {\n                    assertCall(result, test, getArt(test));\n                })\n            });\n        },\n    },\n    'brainfuck': {\n        info: `{bo}Implement a brainfuck interpreter that supports: [ ] > < + - .`,\n        test: (solution) => {\n            const bfgen = IRC.require('bfgen');\n            const bf = IRC.require('bf');\n\n            const tests = `jsgolf|egg!|POOP|brainfuck|wakka|Hello World|#!/bin/bash|javascript|cheese|31337|eatahat|--[----->+<]>-.++..|split|donk|que?|\npowerwank|I live in a blue house with a blue window|SonicTheHedgeHog|superman|batman|united states|america|this is insane|suck some dust|fifty pound note|\nthree dollar bill|hoovering|free FlIgHtS|surge in sales|coca cola|Exploded!|sell more than ever|million|the courts got involved|washing machine|many flights|no cheating|`.split`|`\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach(test => {\n                    assertCall(result, test, bfgen(test));\n                })\n                assertCall(result, 'helloworld', '>++++++++++[>++++++++++>++++++++++>+++++++++++>+++++++++++>+++++++++++>++++++++++++>+++++++++++>+++++++++++>+++++++++++>++++++++++><<<<<<<<<<<-]>++++>+>-->-->+>->+>++++>-->><<<<<<<<<<<>.>.>.>.>.>.>.>.>.>.')\n                assertCall(result, bf('+[>+.<+]'), '+[>+.<+]')\n\n                assertCall(result, '', 'lol')\n            });\n        },\n    }\n};\n\n// tasks.demo = {\n//     displayName: 'DEMO',\n//     public: true,\n//     info: 'eval to 3',\n//     test: (solution) => {\n//         IRC.require('golf.eval')(solution, result => {\n//             assertEq(result, 3);\n//         });\n//     },\n// };\n\n\n// apply some extra info\nObject.keys(tasks).forEach(key => {\n    const task = tasks[key];\n    task.displayName || (task.displayName = key);\n    task.public && (task.info = `{dc}[PUBLIC]{/} ${task.info}`);\n});\n\nconst getTaskUnchecked = (name) => {\n    return tasks[name.toLowerCase().trim()];\n};\n\nconst getTask = (name) => {\n    const task = getTaskUnchecked(name);\n    if (!task) throw `Please choose a valid task`;\n    return task;\n};\n\nconst taskListDisplay = Object.keys(tasks).map(d => tasks[d].displayName);\nconst taskList = Object.keys(tasks);\n\nmodule.exports = {\n    getTask,\n    getTaskUnchecked,\n    taskListDisplay,\n    taskList,\n};\n\nconst tasksPublic = Object.values(tasks).filter(d => d.public).map(d => d.displayName)\nconst tasksPrivate = Object.values(tasks).filter(d => !d.public).map(d => d.displayName)\n\nif (!module.required) {\n    print('{bo}private tasks:{/} ' + tasksPrivate.map(key => `${IRC.colors.nick(key, false)}`).join`, `)\n    if (tasksPublic.length) {\n        print('{bo}public tasks:{/} ' + tasksPublic.map(key => `${IRC.colors.nick(key, false)}`).join`, `)\n    }\n}",
    "locked": false,
    "starred": false
}