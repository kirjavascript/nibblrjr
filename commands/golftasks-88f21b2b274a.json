{
    "name": "golf.tasks",
    "command": "const { inspect } = IRC;\n\n\nconst stringify = (obj) => {\n    return inspect(obj, {\n        colors: false,\n        depth: 0,\n        truncate: 100,\n    });\n};\n\nfunction removeEval() {\n    const _eval = eval;\n    const _function = Function;\n    const stub = eval = Function = function(){throw 'eval disabled'};\n    const _fns = [\n        function(){},\n        async function(){},\n        function*(){},\n        async function*(){},\n    ];\n    const _constructors = _fns.map(fn => {\n        const proto = Object.getPrototypeOf(fn);\n        const _constructor = proto.constructor;\n        delete proto.constructor;\n        proto.constructor = stub;\n        return [_constructor, proto];\n    });\n    return () => {\n        eval = _eval;\n        Function = _function;\n        _constructors.forEach(([c, p], i) => {\n            p.constructor = c;\n        });\n    };\n}\n\nconst { isEqual } = _;\n\nBigInt.prototype.toJSON = function() { return `${this}n`; };\n\nfunction assertType(a, type) {\n    if (typeof a !== type) {\n        throw new Error(`expected {dc}${type}{/} got {o}${typeof a}{/}`);\n    }\n}\n\nfunction assertEq(a, b) {\n    if (!isEqual(a, b)) {\n        throw new Error(`expected {dc}${stringify(b)}{/} got {o}${stringify(a)}{/}`);\n    }\n}\n\nfunction assertCall(result, expected, ...args) {\n    const output = result(...args);\n    if (!isEqual(expected, output)) {\n        const params = args.map(stringify).join`, `;\n        throw new Error(`expected {dc}${stringify(expected)}{/} got {o}${stringify(output)}{/}  (params: {dp}${params}{/})`);\n    }\n}\n\n\nmodule.exports = {\n    'logo': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1JLF') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            const jsgolf = `#############################################\n#                                           #\n#      #  ####   ####   ####  #      ###### #\n#      # #      #    # #    # #      #      #\n#      #  ####  #      #    # #      #####  #\n#      #      # #  ### #    # #      #      #\n# #    # #    # #    # #    # #      #      #\n#  ####   ####   ####   ####  ###### #      #\n#                                           #\n#############################################`;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result.trim(), jsgolf);\n            });\n        },\n    },\n    'ROT13': {\n        task: () => print('{bo}Write a function that returns a ROT13 ciphered version of its input string.\\nYour solution needs to cover the characters; abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('NOPQWXYZabcdefghijklmABCGHIJKLMnopqrstuvwRSTUVDEFxyz'), 'ABCDJKLMnopqrstuvwxyzNOPTUVWXYZabcdefghijEFGHIQRSklm');\n                assertEq(result('HKLMUVDEefgpyzbcdTtuvnoXYNOPQWhijklmqrsZaxABCGwRSIJF'), 'UXYZHIQRrstclmopqGghiabKLABCDJuvwxyzdefMnkNOPTjEFVWS');\n            });\n        },\n    },\n    'hex2rgb': {\n        task: () => print('{bo}Write a function to convert a hex color ({o}#FFFFFF{/}{bo}) or ({o}#FFF{/}{bo}) to rgb ({dc}rgb(255,255,255){/}{bo})'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertEq(result('#B04B4B'), 'rgb(176,75,75)'); \n                assertEq(result('#7E88E6'), 'rgb(126,136,230)'); \n                assertEq(result('#1FA11F'), 'rgb(31,161,31)'); \n                assertEq(result('#123'), 'rgb(17,34,51)'); \n                assertEq(result('#7FFFD4'), 'rgb(127,255,212)');\n                assertEq(result('#B0E0E6'), 'rgb(176,224,230)');\n                assertEq(result('#5F9EA0'), 'rgb(95,158,160)');\n                assertEq(result('#4682B4'), 'rgb(70,130,180)');\n                assertEq(result('#6495ED'), 'rgb(100,149,237)');\n                assertEq(result('#00BFFF'), 'rgb(0,191,255)');\n                assertEq(result('#1E90FF'), 'rgb(30,144,255)');\n                assertEq(result('#ADD8E6'), 'rgb(173,216,230)');\n                assertEq(result('#87CEEB'), 'rgb(135,206,235)');\n                assertEq(result('#87CEFA'), 'rgb(135,206,250)');\n                assertEq(result('#666'), 'rgb(102,102,102)');\n                assertEq(result('#F00'), 'rgb(255,0,0)');\n            });\n        },\n    },\n    'quine': {\n        task: () => print('{bo}Write a quine'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                if (result.length < 1) throw new Error('program length must be non-zero');\n                if (result != solution) throw new Error('output doesn\\'t match source');\n            });\n        },\n    }, \n    'cross': {\n        task: () => print('{bo}Write an expression that evaluates to the string:{/} ' + IRC.colors.link('http://ix.io/1FZt') + ' (the string is trimmed before comparison)'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const art = `#......#\\n.#....#.\\n..#..#..\\n...##...\\n...##...\\n..#..#..\\n.#....#.\\n#......#`;\n                assertType(result, 'string');\n                assertEq(result.trim(), art);\n            });\n        },\n    },\n    'wordpath': {\n        task: () => print(`{bo}Given two single words, return a word path ({y}array{/}{bo}) from word a to word b where the word changes one character at every step. All steps have to be valid words in the dictionary at {p}global.words{/}{bo}, and all words will be of length 4. for example: ('more', 'fact') => ['more', 'fore', 'fort', 'fart', 'fact']. the full wordlist is here: https://paste.rs/I4c`),\n        test: (solution) => {\n            const words = Object.freeze('abed,abid,ahed,ails,ains,aked,albe,albs,aloe,alow,amid,anew,arbs,asar,aunt,axed,axel,axil,bait,bale,balk,bane,bank,bare,barn,base,bays,bazz,beal,bene,bent,best,bile,bima,bine,bint,bobs,boep,bogs,bois,bola,bolo,book,boon,boos,bork,boss,bota,boun,brag,brap,brig,bris,buik,bums,bunt,burk,busk,buss,caca,cain,call,cann,cans,cavy,cill,clow,cobs,coca,coda,come,coms,cone,coof,coop,coos,crab,crag,crow,dans,dead,deaf,dear,deaw,deer,diol,dire,dirl,disa,dish,diva,dobe,doby,dore,dorr,dosh,dote,doun,doup,dour,duck,dush,eans,ease,eats,elks,elts,emes,emic,emit,enew,epic,eres,erns,ests,eugh,exes,exit,eyra,fags,fall,farl,fell,fibs,figs,fill,filo,fils,flow,frig,fris,friz,fros,frow,fuck,fums,gamp,garb,gars,gaus,gays,gien,gies,gips,glow,goaf,goal,goof,goon,goos,gors,gris,gush,gust,gymp,hahs,hail,hare,hark,hauf,haul,haze,head,hear,heat,hell,hent,herd,hery,high,hish,hons,hops,hork,houf,hubs,hups,iris,iwis,kail,kais,kans,keas,kens,khud,kobs,ksar,kuru,lace,laze,lead,lean,lear,leas,lehr,lept,lice,life,limy,lins,liny,lone,loof,loos,lote,lush,lyne,lynx,lyra,maar,maas,mala,malt,mats,meal,meck,mere,mese,mesh,mick,mini,miny,mosh,muni,murk,mush,muti,nain,nams,nats,naze,nigh,oboe,obol,ohed,oink,ordo,ords,oups,past,peck,pips,plot,plow,pock,poep,poke,pone,pons,poon,poop,poot,post,pugh,push,rahs,rait,rare,rase,raze,razz,read,rean,redd,reno,reny,riff,rifs,rima,rimu,roke,rota,rurp,ruru,rusk,sall,salp,salt,samp,scry,sept,sext,shen,shew,shim,shin,ship,shit,shop,sigh,sigs,sile,silo,sinh,sink,skeg,sken,slit,soda,sogs,solo,soop,spec,spic,spry,sten,swam,swan,swim,tala,tehr,tene,thin,thud,tiff,toff,tops,umph,umpy,vale,viae,vine,vire,wale,waly,wast,wavy,waxy,wink,wins,wons,yaar,yarn,yelm,yelp,yest,yock,ywis'.split`,`);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                const _result = result;\n                result = (...args) => {\n                    global.words = words\n                    return _result(...args);\n                };\n\n                const diff = (a, b) => {\n                    let count=0;\n                    for(let i=0; i< a.length; i++) {\n                        if( a[i] !== b[i]) count++\n                    }\n                    return count\n                }\n\n                function assertPath(start, end) {\n                    const wordpath = result(start, end);\n                    if (wordpath.length < 2) {\n                        throw 'word path is not long enough'\n                    }\n                    if (wordpath[0] !== start) {\n                        throw `first word in array is not ${start}`\n                    }\n                    if (wordpath[wordpath.length-1] !== end) {\n                        throw `last word in array is not ${end}`\n                    }\n\n                    if( wordpath.map( w => words.includes( w)).filter( x=>x===false).length>0) {\n                        throw ( 'some of those words are probably not real words')\n                    }\n                    for(let i=0; i< wordpath.length-1; i++) {\n                        if(diff( wordpath[i], wordpath[i+1])!==1) {\n                            throw ( wordpath[i] + ' and ' + wordpath[i+1] + ' either differ too much or are the same')\n                        }\n                    }\n                }\n\n                [[\"swim\", \"shim\"], [\"ohed\", \"amid\"], [\"pugh\", \"dosh\"], [\"coof\", \"cobs\"], [\"goal\", \"loof\"], [\"khud\", \"khud\"], [\"pons\", \"roke\"], [\"eugh\", \"pugh\"], [\"loos\", \"garb\"], [\"dans\", \"nain\"], [\"flow\", \"crow\"], [\"lote\", \"dour\"], [\"yelm\", \"yelp\"], [\"viae\", \"bint\"], [\"rota\", \"solo\"], [\"soop\", \"soop\"], [\"boon\", \"doup\"], [\"lush\", \"gust\"], [\"friz\", \"brap\"], [\"oboe\", \"obol\"], [\"anew\", \"enew\"], [\"lyra\", \"eyra\"], [\"poon\", \"wast\"], [\"yarn\", \"ease\"], [\"hery\", \"redd\"], [\"elks\", \"nams\"], [\"boep\", \"shop\"], [\"deaw\", \"deer\"], [\"goon\", \"murk\"], [\"lead\", \"rean\"], [\"oink\", \"wons\"], [\"rait\", \"bait\"], [\"swan\", \"swim\"], [\"rahs\", \"hahs\"], [\"life\", \"laze\"], [\"waxy\", \"vale\"], [\"gien\", \"pips\"], [\"umpy\", \"umph\"], [\"coos\", \"coos\"], [\"meal\", \"meal\"], [\"ests\", \"kens\"], [\"lept\", \"sext\"], [\"fags\", \"nigh\"], [\"exes\", \"emes\"], [\"yaar\", \"mats\"], [\"buss\", \"fums\"], [\"shin\", \"thin\"], [\"peck\", \"yock\"], [\"high\", \"diva\"], [\"spec\", \"exit\"], [\"hons\", \"tops\"], [\"meck\", \"mick\"], [\"salt\", \"tala\"], [\"tene\", \"bare\"], [\"rifs\", \"toff\"], [\"ywis\", \"bois\"], [\"oups\", \"hubs\"], [\"rare\", \"rase\"], [\"hent\", \"deaf\"], [\"alow\", \"arbs\"], [\"hear\", \"keas\"], [\"skeg\", \"sten\"], [\"waly\", \"cavy\"], [\"bobs\", \"sogs\"], [\"diol\", \"vire\"], [\"boss\", \"kobs\"], [\"naze\", \"hork\"], [\"gymp\", \"sall\"], [\"crag\", \"crab\"], [\"spry\", \"scry\"], [\"reny\", \"reno\"], [\"bazz\", \"raze\"], [\"gaus\", \"bays\"], [\"ordo\", \"ords\"], [\"glow\", \"plot\"], [\"duck\", \"fuck\"], [\"muni\", \"muti\"], [\"mere\", \"mosh\"], [\"asar\", \"ksar\"], [\"bank\", \"sile\"], [\"houf\", \"kais\"], [\"ails\", \"lins\"], [\"axil\", \"aked\"], [\"hell\", \"farl\"], [\"slit\", \"ship\"], [\"frow\", \"gris\"], [\"rurp\", \"kuru\"], [\"buik\", \"rusk\"], [\"tehr\", \"lear\"], [\"doby\", \"doby\"], [\"lynx\", \"coms\"], [\"soda\", \"caca\"], [\"yest\", \"aunt\"], [\"limy\", \"muni\"], [\"bima\", \"rimu\"], [\"sinh\", \"sink\"], [\"erns\", \"eres\"], [\"shen\", \"shew\"], [\"fibs\", \"silo\"], [\"push\", \"mush\"], [\"fibs\", \"call\"]].forEach(([a,b]) => {\n                        assertPath(a, b)\n                        assertPath(b, a)\n                    });\n\n            });\n        }\n\n\n\n    },\n    'numberWords': {\n        task: () => print('{bo}Write a function that takes a number, and returns a space-delimited word representation of that number. \\nFor example, given 120 as input you would return \\'one two zero\\'  {/}'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                if (\n                    result(123) !== 'one two three' ||\n                    result(90807) !== 'nine zero eight zero seven' ||\n                    result(564) !== 'five six four' ||\n                    result(120349) !== 'one two zero three four nine'\n                ) throw new Error('received invalid result');\n            });\n        }\n    },\n    pyramid: {\n          task: () => print('{bo}Given a positive integer, draw an ASCII pyramid with as many rows. For example, given a 2: \\n /\\\\\\n/__\\\\\\n'),\n          test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 1, '/\\\\\\n' ],\n                    [3, '  /\\\\\\n /  \\\\\\n/____\\\\\\n'],\n                    [8, '       /\\\\\\n      /  \\\\\\n     /    \\\\\\n    /      \\\\\\n   /        \\\\\\n  /          \\\\\\n /            \\\\\\n/______________\\\\\\n'],\n                    [32, '                               /\\\\\\n                              /  \\\\\\n                             /    \\\\\\n                            /      \\\\\\n                           /        \\\\\\n                          /          \\\\\\n                         /            \\\\\\n                        /              \\\\\\n                       /                \\\\\\n                      /                  \\\\\\n                     /                    \\\\\\n                    /                      \\\\\\n                   /                        \\\\\\n                  /                          \\\\\\n                 /                            \\\\\\n                /                              \\\\\\n               /                                \\\\\\n              /                                  \\\\\\n             /                                    \\\\\\n            /                                      \\\\\\n           /                                        \\\\\\n          /                                          \\\\\\n         /                                            \\\\\\n        /                                              \\\\\\n       /                                                \\\\\\n      /                                                  \\\\\\n     /                                                    \\\\\\n    /                                                      \\\\\\n   /                                                        \\\\\\n  /                                                          \\\\\\n /                                                            \\\\\\n/______________________________________________________________\\\\\\n'],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input), output);\n                });\n            });\n          }\n    },\n    triangle: {\n        task: () => print('{bo}Provide a function that returns the nth row of pascal\\'s triangle as an array of numbers'),\n        test: (solution) => {\n            const { pascal } = require('pascal-triangle');\n            const triangle = pascal(30);\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                for(let i = 1; i < 30; i++) {\n                    assertCall(result, triangle[i-1], i);\n                }\n            });\n        },\n    },\n    'miniJSON': {\n        task: () => print('{bo}Create a JSON parser that handles {y}strings{/}{bo}, {y}numbers{/}{bo}, and {y}arrays{/}{bo}. (You cannot use {dc}eval{/}{bo} or the {dc}JSON{/}{bo} object)'),\n        test: (solution) => {\n\n            const tests = [` 123\n                `,` [1, 2, 3]\n                `,` [[12, 2, [3]], []]\n                `,` \"hello world\"\n                `,` \"hello \\\\\" world\"\n                `,` 123e5\n                `,` [\"bork\", 123]\n                `,` \"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"\\\\\"''''\"\n                `,` [123, \"[123, \", 123]\n                `,` [123, [], [], [], [123],[]   ,   []]\n                `,` [1e2,3e4,     999]\n                `,` [1,2,3, [\"extra stuff\"]]\n                `,` [\"\",1,[\"[[]]\"],2,[[],[[[],\"][\",[3.14]]],\"][\"]]\n                `,` \"\"\n                `,` -14e-3\n                `,` 1.11e+113\n                `,` \" \"\n                `,` \"\\\\\\\\\"\n                `,` \"\\\\\\\\\\\\\\\"\"\n                `,` \"\\\\\\\\\\\\\\\\\"\n                `,` [\"these\", [\"are\", [\"strings\", [\"inside\", [\"arrays\"]]]]]\n                `,` [[[[],[[[31337]]]]],[]]\n                `,` 1e10\n                `,` 0\n                `,` [[\"0\", \"[0,[0]\"], [0]]\n            `]\n\n            const cases = tests.map(test => [test, JSON.parse(test)]);\n            const trueJSON = global.JSON;\n            delete global.JSON;\n            const golfEval = IRC.require('golf.eval');\n            const restoreEval = removeEval();\n            let error;\n            try {\n                golfEval(solution, result => {\n                    assertType(result, 'function');\n                    cases.forEach(([input, expected]) => {\n                        assertCall(result, expected, input);\n                    });\n                });\n            } catch (e) {\n                error = e;\n            }\n\n            // cleanup\n            restoreEval();\n            global.JSON = trueJSON;\n\n            // rethrow any collected errors\n            if (error) {\n                throw error;\n            }\n        },\n    },\n    blockmatrix: {\n        task: () => print('{bo}Given a binary matrix, construct a string using block characters (â–– â–— â–˜ â–™ â–š â–› â–œ â– â–ž â–Ÿ â–€ â–„ â–ˆ â–Œ â–). 1char = 4 pixels'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                assertType(result([[0,0], [0,0]]), 'string');\n                [\n                    [[[0,1], [1,0]], \"â–ž\"],\n                    [[[1,1,1,0],[0,0,1,1]], \"â–€â–™\"],\n                    [[[1,1],[1,1]], \"â–ˆ\"],\n                    [[[1,1],[0,1]], \"â–œ\"],\n                    [[[1,1,0,1],[1,1,1,1]], \"â–ˆâ–Ÿ\"],\n                    [[[0,1,0,1],[0,1,0,1]], \"â–â–\"],\n                    [[[1,0],[1,0]], \"â–Œ\"],\n                    [[[1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0],[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0],[1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0]], \"â–›â––â–žâ––â–žâ––â–›â––\\nâ–› â–šâ–˜â–šâ–˜â–› \"],\n                    [[[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,1,1,0,0,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,1,1,1,0],[0,0,1,1,1,1,1,1,1,1,0,0],[0,0,0,1,1,1,1,1,1,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,1,0,0,0,0,0]], \" â–„â––â–—â–„ \\nâ–â–ˆâ–ˆâ–ˆâ–ˆâ–Œ\\n â–œâ–ˆâ–ˆâ–› \\n  â–œâ–›  \"],\n                    [[[1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,0],[0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1],[0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,1,0,1],[1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,1],[0,1,0,1,0,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,0,1,0,0],[0,1,0,1,0,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1]], \"â–€â–˜â–˜â–˜â–€â–â–žâ––â–—â–šâ– â– â–ž \\nâ–—â–˜â––â–š  â–šâ–â– â–šâ–˜â–Œâ–žâ–—â–\\nâ–œâ–šâ–â–žâ–›â–ˆâ–ˆâ–›â–€â––â–â––â–â– â–ž\\nâ–â–—â–šâ–â–Ÿâ–Ÿâ–žâ–žâ–â–šâ–œâ–œâ–œâ–â–žâ–—\"],\n                ].forEach(([input, output]) => {\n                    assertEq(result(input).replace(/\\n+$/,''), output);\n                })\n            });\n        },\n\n    },\n    prime: {\n        task: () => print(`{bo}Write an script that evaluates to an array containing all prime numbers below 1000 in order`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'object');\n                assertEq(result, [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]);\n            });\n        },\n    },\n    pi: {\n        task: () => print(`{bo}Write a script that evaluates to a string containing the the first 100 decimal places of pi ({/}{dg}'3.14159 ...'{/}{bo})`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result, '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679');\n            });\n        },\n    },\n    'vowelratio': {\n        task: () => print('{bo}Calculate the simplified ratio of vowels [aeiou] to consonants in a given string. For example, {/}{dc}cake{/}{bo} would give {/}{dg}\"1:1\"'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                [\n                    [ 'cake', '1:1' ],\n                    [ 'no', '1:1' ],\n                    [ 'x', '0:1' ],\n                    [ 'oaie', '1:0' ],\n                    [ 'xx', '0:1' ],\n                    [ 'golf', '1:3' ],\n                    [ 'figuratively', '5:7' ],\n                    [ '1e5', '1:0'],\n                    [ '0xff', '0:1'],\n                    [ '0xf', '0:1'],\n                    [ '1e9999', '1:0' ],\n                    [ '1.1e0', '1:0' ],\n                    [ 'the quick brown fox jumped over the lazy dog.', '1:2' ],\n                    [ 'lololol', '3:4' ],\n                    [ 'mozilla firefoxâ„¢', '3:4' ],\n                    [ 'kirjava was here 2019', '3:4' ],\n                    [ 'The C/++ Programming Language', '8:15' ],\n                    [ 'bleh bleh bleh', '1:3' ],\n                    [ 'how are you enjoying the task', '5:7' ],\n                    [ 'adding more test cases', '7:12' ],\n                    [ \"I'm blue da ba dee da ba daa, da ba dee, da be daa\", '19:15' ],\n                    [ 'rustlang', '1:3' ],\n                    [ 'powerwank', '1:2' ],\n                    [ 'sega genesis', '5:6' ],\n                    [ 'chip-8', '1:3' ],\n                    [ 'oh wait these dont actually have to be real words', '2:3' ],\n                    [ 'saduhfgaiulewdfahlusdfghuasdgfa', '11:20' ],\n                    [ 'asdajasdjflkas jasldalkhjwjw', '2:7' ],\n                    [ 'as dkhnasbd anl dwk alknbwd aw', '1:4' ],\n                    [ 'aksdjalksjdaklsasdca gjokdfiogboi', '5:11' ],\n                    [ 'isdfvosoiu hg sdknlfsnkjflknsd nk', '1:5' ],\n                ].forEach(([input, expected]) => {\n                    assertCall(result, expected, input);\n                });\n            });\n        },\n    },\n    'helloworld': {\n        task: () => print('{bo}Write a script that evaluates to the string {dg}\"Hello World\"{/}{bo}. You cannot use {y}quotes{/}{bo}, {y}slashes{/}{bo} or {y}round brackets{/}{bo}'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`\\/\\\\\\(\\)]/g, d => `{r}${d}{/}`);\n                if (/[\"'`\\/\\\\\\(\\)]/.test(solution)) {\n                    throw new Error(`your solution contains disallowed characters: ${highlighted}`);\n                }\n                assertEq(result, 'Hello World');\n            });\n        },\n    },\n    'longstring': {\n        task: () => print('{bo}Write a script that evaluates to a string of length 17707. You cannot use {y}quote{/}{bo} or {y}number{/}{bo} characters'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                const highlighted = solution.replace(/[\"'`]/g, d => `{r}${d}{/}`).replace(/\\d+/g, d => `{r}${d}{/}`);\n                if (/[\"'`]/.test(solution) && /\\d/.test(solution)) {\n                    throw new Error(`your solution contains quote and number characters: ${highlighted}`);\n                }\n                if (/[\"'`]/.test(solution)) {\n                    throw new Error(`your solution contains quote characters: ${highlighted}`);\n                }\n                if (/\\d/.test(solution)) {\n                    throw new Error(`your solution contains number characters: ${highlighted}`);\n                }\n\n                if (result.length !== 17707) {\n                    throw new Error(`expected length {dc}17707{/} got {o}${result.length}{/}`);\n                }\n            });\n        },\n    },\n    'RPN': {\n        task: () => print('{bo}Write a function that evaluates reverse polish notation'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                // https://www.mathblog.dk/tools/infix-postfix-converter/\n                // https://lab.miguelmota.com/postfix-calculator/demo/\n                assertEq(result('15 7 1 1 + - / 3 * 2 1 1 + + -'), 5);\n                assertEq(result('3 3 5 3 * / + 10 +'), 13.2);\n                assertEq(result('3 3 3 / * 1239 +'), 1242);\n                assertEq(result('3 3 / 3 3 / * 1239 +'), 1240);\n                assertEq(result('31337 187123 * 99 -234875 4 / + +'), 5863814831.25);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 1234 * +'), 3234837776359);\n                assertEq(result('123 3443 2 / 1234 * 1234 * 123 * +'), 322435207965);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 57);\n                assertEq(result('3 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 4 + 3 + 3 + 3 + 3 + 3 + 3 + 3 +'), 58);\n                assertEq(result('1 3 * 10 + 0 +'), 13);\n                assertEq(result('-1 -1 -'), 0);\n                assertEq(result('-1 -10 -'), 9);\n                assertEq(result('1'), 1);\n            });\n        },\n    },\n    boggle: {\n        task: () => print('{bo}Given a string of 16 characters and a word, return true if that word can be made using a 4x4 Boggle grid made from the 16 characters (4 x 4 rows).'),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                const assert = (grid, word, res) => { \n                    assertEq(result(grid, word), res);\n                };\n\n                assert( 'bsoitlshnreolfis', 'shoes', true);\n                assert( 'bsoitlshnreolfis', 'heirs', true);\n                assert( 'bsoitlshnreolfis', 'flesh', false);\n\n                assert( 'piohdmleosxesent', 'sextet', false);\n                assert( 'piohdmleosxesent', 'doses', true);\n                assert( 'piohdmleosxesent', 'dome', false);\n\n                assert( 'iosietpregiediah', 'poster', false);\n                assert( 'iosietpregiediah', 'baboon', false);\n                assert( 'iosietpregiediah', 'spirited', true);\n\n                assert( 'enesddssnbmeaint', 'absentmindedness', true);\n                assert( 'gbaiessxtsseazsl', 'assesses', true);\n                assert( 'ioioiooioioioioi', 'ioioioioioioioio', true);\n                assert( 'saibissaesseasaa', 'assasssassa', false);\n                assert( \"hasezxclrtolpoit\", \"hello\", false);\n                assert('..WORD..........', 'WORD', false);\n                assert('zxcvasdfqwerasdf', 'dewax', true);\n            });\n        }\n    },\n    'romanNumerals': {\n        task: () => print(`{bo}Write a function that converts a positive integer to roman numerals`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(num), str);\n                });\n            });\n        },\n    },\n    'romanNumerals2': {\n        task: () => print(`{bo}Write a function that converts a roman numeral into an integer`),\n        test: (solution) => {\n            IRC.require('golf.eval')(solution, result => {\n                const tests = [\n                    [1, 'I'],\n                    [3, 'III'],\n                    [4, 'IV'],\n                    [500, 'D'],\n                    [40, 'XL'],\n                    [123, 'CXXIII'],\n                    [546, 'DXLVI'],\n                    [3456, 'MMMCDLVI'],\n                    [1337, 'MCCCXXXVII'],\n                    [3999, 'MMMCMXCIX'],\n                    [1024, 'MXXIV'],\n                    [2925, 'MMCMXXV'],\n                    [1111, 'MCXI'],\n                    [67, 'LXVII'],\n                    [49, 'XLIX'],\n                    [32, 'XXXII'],\n                    [1001, 'MI'],\n                ];\n                assertType(result, 'function');\n                tests.forEach(([num, str]) => {\n                    assertEq(result(str), num);\n                });\n            });\n        },\n    },\n    'toMorse': {\n        task: () => print(`{bo}Write a function that converts text to morse code. You need one space between letters, and three between words`),\n        test: (solution) => {\n            const lookup = { '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', 'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 'y': '-.--', 'z': '--..', ' ': ' ' };\n\n            const solve = (s) => [...s].map(l => lookup[l.toLowerCase()]).join` `;\n\n            const tests = [ 'bum', '12345', 'caSh MoNey', 'hello world', '1e999 is infinity', 'pooooop Abcdefghijklmnopqrstuvwxyz 0 1234 5 6 7 8 81012', '1337 hax m8', 'futurama', 'nibblrjr', 'golf and more golf', 'sigh test cases', 'and more and more', 'and then even some more', 'it just has to keep going until its too many for someone to cheat with ' ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach((str) => {\n                    assertCall(result, solve(str), str)\n                });\n            });\n        },\n    },\n    'shortestPath': {\n        task: () => print(`{bo}Write a function to find the shortest path in a graph. Vertices are named with single letter, case sensitive. Input is given as edge array, start vertex, destination vertex, i.e., ['AB1',...], 'A', 'B'. 'AB1' means that edge between A and B vertices is of length 1. Output should be an array of path length and path, i.e., [1,'AB']. If no path is available, return [Infinity].`),\n        test: (solution) => {\n            const graphs = [\n                [[\"AI2\",\"AH47\",\"AG53\",\"AE75\",\"CD39\",\"CE84\",\"DG69\",\"DE28\",\"EG17\",\"FI29\",\"FD46\",\"FH44\",\"FB46\",\"GH54\",\"HB95\",\"HC4\",\"IG94\",\"IC14\",\"IB9\"],\"G\",\"B\"],\n                [[\"AM23\",\"Ba87\",\"BH84\",\"BD6\",\"BA48\",\"CF30\",\"CM51\",\"CH43\",\"CG29\",\"DH63\",\"DA61\",\"Da60\",\"DI76\",\"DG27\",\"EF73\",\"EM77\",\"EI31\",\"FG73\",\"GL21\",\"GE67\",\"GM25\",\"HA65\",\"IF65\",\"IM54\",\"IG42\",\"JD34\",\"JG23\",\"LE19\",\"LD29\",\"LC83\",\"LA38\",\"La76\",\"LM73\",\"MB66\",\"MD63\"],\"K\",\"I\"],\n                [[\"AC22\",\"AF65\",\"CG2\",\"CB38\",\"EG64\",\"EB48\",\"EA24\",\"GB62\",\"GD6\"],\"C\",\"F\"],\n                [[\"BC7\",\"BD46\",\"CA12\",\"CH77\",\"DJ31\",\"DA50\",\"EJ63\",\"FA49\",\"HJ73\",\"HK30\",\"HA31\",\"IK81\",\"IG81\",\"IA17\",\"KA78\",\"KD54\",\"KC80\"],\"E\",\"H\"],\n                [[\"BA74\",\"BC41\",\"DA74\",\"DC51\",\"EC42\",\"ED34\"],\"E\",\"A\"],\n                [[\"AL5\",\"AB61\",\"BJ12\",\"BF62\",\"CD45\",\"DH43\",\"DA56\",\"EH75\",\"EF92\",\"EJ7\",\"FJ7\",\"FM16\",\"FA68\",\"GI15\",\"GM13\",\"HL78\",\"Ia77\",\"IC68\",\"IM51\",\"JC17\",\"KD4\",\"KG68\",\"KE54\",\"LB18\",\"aL20\"],\"A\",\"L\"],\n                [[\"AH61\",\"AD10\",\"AC29\",\"AG27\",\"BC53\",\"BE32\",\"CI95\",\"CD3\",\"DE20\",\"DG80\",\"EK92\",\"HI42\",\"HJ97\"],\"J\",\"E\"],\n                [[\"AL91\",\"AK98\",\"AI15\",\"BD60\",\"BA46\",\"BG12\",\"BH31\",\"BE4\",\"CB96\",\"CJ13\",\"DJ28\",\"DH35\",\"DC42\",\"FG16\",\"HF73\",\"HK46\",\"JB44\",\"JA55\",\"LE37\",\"LB34\",\"LJ39\"],\"F\",\"G\"],\n                [[\"AF12\",\"AC49\",\"AL78\",\"CI5\",\"CB76\",\"EG61\",\"FI9\",\"GF52\",\"GA20\",\"HE15\",\"HF94\",\"HM49\",\"IE37\",\"IK20\",\"JF8\",\"LH86\",\"LJ33\",\"LE38\",\"MI60\"],\"C\",\"I\"],\n                [[\"AE51\",\"AC27\",\"BF84\",\"BD51\",\"BE5\",\"BA6\",\"CB74\",\"DC63\",\"DF13\",\"EF59\",\"EC22\",\"FA84\"],\"F\",\"B\"],\n                [[\"AI2\",\"AH47\",\"AG53\",\"AE75\",\"CD39\",\"CE84\",\"DG69\",\"DE28\",\"EG17\",\"FI29\",\"FD46\",\"FH44\",\"FB46\",\"GH54\",\"HB95\",\"HC4\",\"IG94\",\"IC14\",\"IB9\"],\"E\",\"I\"],\n                [[\"AM23\",\"Ba87\",\"BH84\",\"BD6\",\"BA48\",\"CF30\",\"CM51\",\"CH43\",\"CG29\",\"DH63\",\"DA61\",\"Da60\",\"DI76\",\"DG27\",\"EF73\",\"EM77\",\"EI31\",\"FG73\",\"GL21\",\"GE67\",\"GM25\",\"HA65\",\"IF65\",\"IM54\",\"IG42\",\"JD34\",\"JG23\",\"LE19\",\"LD29\",\"LC83\",\"LA38\",\"La76\",\"LM73\",\"MB66\",\"MD63\"],\"a\",\"M\"],\n                [[\"AC22\",\"AF65\",\"CG2\",\"CB38\",\"EG64\",\"EB48\",\"EA24\",\"GB62\",\"GD6\"],\"A\",\"G\"],\n                [[\"BC7\",\"BD46\",\"CA12\",\"CH77\",\"DJ31\",\"DA50\",\"EJ63\",\"FA49\",\"HJ73\",\"HK30\",\"HA31\",\"IK81\",\"IG81\",\"IA17\",\"KA78\",\"KD54\",\"KC80\"],\"I\",\"C\"],\n                [[\"BA74\",\"BC41\",\"DA74\",\"DC51\",\"EC42\",\"ED34\"],\"D\",\"B\"],\n                [[\"AL5\",\"AB61\",\"BJ12\",\"BF62\",\"CD45\",\"DH43\",\"DA56\",\"EH75\",\"EF92\",\"EJ7\",\"FJ7\",\"FM16\",\"FA68\",\"GI15\",\"GM13\",\"HL78\",\"Ia77\",\"IC68\",\"IM51\",\"JC17\",\"KD4\",\"KG68\",\"KE54\",\"LB18\",\"aL20\"],\"C\",\"a\"],\n                [[\"AH61\",\"AD10\",\"AC29\",\"AG27\",\"BC53\",\"BE32\",\"CI95\",\"CD3\",\"DE20\",\"DG80\",\"EK92\",\"HI42\",\"HJ97\"],\"H\",\"C\"],\n                [[\"AL91\",\"AK98\",\"AI15\",\"BD60\",\"BA46\",\"BG12\",\"BH31\",\"BE4\",\"CB96\",\"CJ13\",\"DJ28\",\"DH35\",\"DC42\",\"FG16\",\"HF73\",\"HK46\",\"JB44\",\"JA55\",\"LE37\",\"LB34\",\"LJ39\"],\"B\",\"J\"],\n                [[\"AF12\",\"AC49\",\"AL78\",\"CI5\",\"CB76\",\"EG61\",\"FI9\",\"GF52\",\"GA20\",\"HE15\",\"HF94\",\"HM49\",\"IE37\",\"IK20\",\"JF8\",\"LH86\",\"LJ33\",\"LE38\",\"MI60\"],\"H\",\"A\"],\n                [[\"AE51\",\"AC27\",\"BF84\",\"BD51\",\"BE5\",\"BA6\",\"CB74\",\"DC63\",\"DF13\",\"EF59\",\"EC22\",\"FA84\"],\"B\",\"F\"],\n    [[\"ab1\", \"bc1\", \"cu1\", \"uv1\", \"wx1\"], \"a\",\"x\"],\n    [[\"au1\", \"bv12\", \"cw3\", \"dx17\"], \"a\",\"x\"], \n            ];\n\n            const results = [ [64,[\"GAIB\"]], [Infinity], [87,[\"CAF\"]], [136,[\"EJH\"]], [108,[\"EDA\"]], [5,[\"AL\"]], [188,[\"JHADE\"]], [16,[\"FG\"]], [5,[\"CI\"]], [64,[\"FDB\",\"FEB\"]], [72,[\"EGAI\"]], [112,[\"aDGM\"]], [24,[\"ACG\"]], [29,[\"IAC\"]], [92,[\"DCB\"]], [67,[\"CJBLa\"]], [74,[\"HADC\"]], [44,[\"BJ\"]], [73,[\"HEIFA\"]], [64,[\"BDF\",\"BEF\"]], [Infinity], [Infinity] ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n\n                graphs.map((args, i) => {\n                    // fn is user submitted function\n                    const data = result(...args);\n                    if (!Array.isArray(data)) {\n                        throw new Error(`expected an {y}array{/} as the return type`);\n                    }\n                    const [rLength, rPath] = data;\n                    const [length, path] = results[i];\n                    if (length !== rLength) {\n                        throw new Error(`expected length {dc}${length}{/} got {o}${rLength}{/}`);\n                    }\n                    if (length !== Infinity && !path.includes(rPath)) {\n                        throw new Error(`path incorrect: expected {o}${path.join` or `}{/}`);\n                    }\n                });\n            });\n        },\n    },\n    'polyfill': {\n        task: () => print(`{bo}Polyfill Array.prototype.sort`),\n        test: (solution) => {\n            const tests = [\n\n                [_.shuffle(_.range(10, 20)), (a, b) => b - a], \n                [_.shuffle(_.range(10, 20)), (a, b) => a - b], \n                [_.shuffle(_.range(10, 20)).map(String), (a, b) => a - b], \n                [_.shuffle(_.range(10, 20)), undefined], \n                [_.shuffle(_.range(10, 20)).map(value => ({ value })), (a, b) => a.value - b.value], \n                [[...'hello world'], undefined],\n                [['March', 'Jan', 'Feb', 'Dec'], undefined],\n                [_.shuffle(_.range(-20, 20)), (a, b) => a - b], \n                [[...'ðŸŽ±â›³ï¸ðŸŽ¿ðŸ‚ðŸŽ£ðŸŠðŸ„ðŸ›€ðŸ†ðŸŽ½ðŸŽ«ðŸŽ­ðŸŽ¨ðŸŽªðŸŽ¤ðŸŽ§ðŸŽ¼ðŸŽ¹'], undefined],\n                [[], undefined],\n                [[1], undefined],\n                [[1, 5, 10], undefined],\n                [[2, 1, 1, 3, 1, 3, 3], undefined],\n                [[1n, 2, 1], undefined],\n                [[2, 1, 1n], undefined],\n                [[1, \"1\"], undefined],\n                [[\"1\", 1], undefined],\n                [[\"~\"], undefined],\n                [[...'zyxvw'], undefined],\n                // [[undefined, 1, undefined], () => {throw 'boop'}],\n                [[null,, undefined, 1, NaN, 1n, '1', {}, [], new Map], undefined],\n\n            ].map(([list, comp]) => [list, comp, _.cloneDeep(list).sort(comp)]);\n            const { sort } = Array.prototype;\n            delete Array.prototype.sort;\n            IRC.require('golf.eval')(solution, result => {\n                assertType(Array.prototype.sort, 'function');\n                function assertSort(_list, _expected, comp) {\n                    const expected = [..._expected];\n                    const list = [..._list];\n                    const original = [...list];\n                    const output = list.sort(comp);\n                    if (output !== list) {\n                        throw new Error('must mutate original array');\n                    }\n                    if (!isEqual(expected, output)) {\n                        throw new Error(`expected {dc}${stringify(expected)}{/} got {o}${stringify(output)}{/}  (items: {dp}${stringify(original)}{/} comparison: {dp}${comp}{/})`);\n                    }\n                }\n\n                tests.forEach(([list, comp, expected]) => {\n                    assertSort(\n                        list,\n                        expected,\n                        comp,\n                    );\n                });\n                let caughtObj = false;\n                let caughtNull = false;\n                try { [].sort({}); } catch { caughtObj = true; }\n                try { [].sort(null); } catch { caughtNull = true; }\n\n                if (!caughtObj || !caughtNull) {\n                    throw new Error('must throw if the comparison is obj or null');\n                }\n                // const { enumerable } = Object.getOwnPropertyDescriptor(Array.prototype, 'sort');\n                // if (enumerable) {\n                //     throw new Error('Array.prototype.sort is meant to not be enumerable');\n                // }\n            });\n            Array.prototype.sort = sort;\n            IRC.require('golf.eval')(solution, result => {\n                if (Array.prototype.sort !== sort) {\n                    throw new Error('replacing native prototypes is bad practise');\n                }\n            });\n        },\n    },\n    mostVisited: {\n        task: () => print(`{bo}https://gist.github.com/nderscore/6765d4f51267c93f700921729b32ac2e`),\n        test: (solution) => {\n            function mostVisited(path) {\n                let mostVisitedIndex = 0;\n                let mostVisitedTimes = 0;\n\n                let arr = new Array(Math.max(...path)).fill(0);\n\n                for (let index = 0; index <= path.length; index++) {\n                    let start = path[index];\n                    let next = path[index + 1];\n\n                    if (!next) {\n                        break;\n                    }\n\n                    if (next > start) {\n                        for (let i = start; i <= next; i++) {\n                            let arrIndex = i - 1;\n                            arr[arrIndex]++;\n                            let visitedValue = arr[arrIndex];\n                            if (\n                                visitedValue > mostVisitedTimes ||\n                                (visitedValue === mostVisitedTimes && arrIndex <= mostVisitedIndex)\n                            ) {\n                                mostVisitedTimes = visitedValue;\n                                mostVisitedIndex = arrIndex;\n                            }\n                        }\n                    } else {\n                        for (let i = next; i <= start; i++) {\n                            let arrIndex = i - 1;\n                            arr[arrIndex]++;\n                            let visitedValue = arr[arrIndex];\n                            if (\n                                visitedValue > mostVisitedTimes ||\n                                (visitedValue >= mostVisitedTimes && arrIndex <= mostVisitedIndex)\n                            ) {\n                                mostVisitedTimes = visitedValue;\n                                mostVisitedIndex = arrIndex;\n                            }\n                        }\n                    }\n                }\n                return mostVisitedIndex + 1;\n            }\n            const r=_=>(0|Math.random()*10)+1;\n            const t=_=>[...Array(r``+1)].map(r);\n\n            const tests = [\n                [1, 5, 3, 2],\n                [9, 3, 5, 6],\n                [1, 6, 5, 6, 4, 2, 1, 2],\n                [4, 9, 5, 9, 3],\n                [1,2,3,4,5,6,4, 11],\n                [4,5,3],\n                [6,5],\n                [ 4, 8, 2, 9, 3, 5, 9, 4, 5, 10, 5 ],\n                [ 7, 10, 10, 4, 10, 2, 4 ],\n                [1,5,3,5,2,4,1,4],\n                [2,10],\n                ...[...Array(300)].map(t),\n            ];\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach((arr) => {\n                    assertCall(result, mostVisited([...arr]), [...arr])\n                });\n            });\n            // https://gist.github.com/jurgenzz/42732a830bafccb3b8fb5b0805ddc6fb\n            // https://l.jurg.is/uploads/64d710152fb99888/\n        },\n    },\n    'chunk': {\n        task: () => print(`{bo}Write a function that given an {y}Array|String{/}{bo} and a {y}Number{/}{bo} creates an array of elements split into groups with the length specified. If it cannot be split evenly, the final chunk will be the remaining elements`),\n        test: (solution) => {\n            const tests = [\n                [_.shuffle(_.range(10, 20)), 2],\n                [_.shuffle(_.range(10, 20)), 4],\n                [[{}, [], {}, [], {}, [], {foo: 1}], 3],\n                ['js golf?', 1],\n                ['js golf?', Infinity],\n                [[undefined,undefined,undefined,undefined,undefined,undefined], 2],\n                [[undefined,undefined,undefined,undefined,undefined,undefined], 1],\n                [[false, 0, 0, 0], 1],\n                [[,,,,,,], 2],\n                [[], 9],\n                [[[[[]]], [[],[],[]], [[], []]], 2],\n                ['hello world', 2],\n                [String({}), 3],\n                [String(function(){}), 5],\n            ].map(([input, chunkBy]) => [input, chunkBy, _.chunk(input, chunkBy)]);\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'function');\n                tests.forEach(([input, chunkBy, expected]) => {\n                    const data = typeof input === 'string' ? input : [...input];\n                    assertCall(result, expected, data, chunkBy)\n                });\n            });\n        },\n    },\n    'toString': {\n        task: () => print(`{bo}Write an expression that evaluates to the string {g}toString{/}{bo}. You cannot use strings and the only sequence of alphanumerics in your solution must be {dc}\\`toString\\``),\n        test: (solution) => {\n\n            let invalid = 0;\n            const highlighted = solution.replace(/[0-9a-z]+/ig, a => {\n                const extra = a.replace(/toString/g, '');\n                if (extra.length) {\n                    invalid += 1;\n                    return `{r}${a.replace(/toString/g, '{/}toString{r}')}{/}`;\n                } else {\n                    return a;\n                }\n            });\n\n            if (/[\"'`]/.test(solution)) {\n                throw new Error(`your solution contains quote characters: ${solution.replace(/[\"'`]/g, d => `{r}${d}{/}`)}`);\n            }\n            if (invalid) {\n                throw new Error(`your solution contains alphanumeric characters that are not {dc}\\`toString\\`{/}: ${highlighted}`);\n            }\n\n            IRC.require('golf.eval')(solution, result => {\n                assertType(result, 'string');\n                assertEq(result, 'toString');\n            });\n        },\n    },\n};\n\nif (IRC.command.path == 'golf.tasks') {\n    print('{bo}available tasks:{/} ' + Object.keys(module.exports).map(key => `${IRC.colors.nick(key, false)}`).join`, `)\n}",
    "locked": false,
    "starred": false
}