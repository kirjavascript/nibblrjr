{
    "locked": false,
    "starred": false,
    "name": "kao",
    "command": "// Â© 2042 do not steal\n\nconst {\n    str,\n    char,\n    digits,\n    possibly,\n    sequenceOf,\n    regex,\n    anythingExcept,\n    anyOfString,\n    many1,\n    many,\n    choice,\n    whitespace,\n    between,\n    recursiveParser,\n} = require('arcsecond');\n\nconst delim = (prefix, surround) => (\n    between(str(`${prefix}${surround}`))(char(surround)) (\n        many(choice([\n            str(`\\\\${surround}`).map(() => surround),\n            anythingExcept(char(surround)),\n        ]))\n    ).map(arr => arr.join``)\n);\n\n// ascii\n\nconst asciiCode = choice([\n    sequenceOf([\n        str('@x'),\n        regex(/^[0-9a-fA-F]+/g),\n    ]).map(([_, h]) => String.fromCodePoint(parseInt(h, 16))),\n    sequenceOf([\n        char('@'),\n        digits,\n    ]).map(([_, d]) => String.fromCodePoint(d)),\n    delim('@', \"'\").map(ch => {\n        if (!ch) return 'âœ–';\n        const code = ch.codePointAt(0);\n        return `${code}-0x${code.toString(16)}-${code.toString(36)}`;\n    }),\n    delim('', '`').map(ch => String.fromCodePoint(parseInt(ch || 0, 36))),\n]);\n\n// text replacement\n\nconst normal = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()';\nconst aesthetic = 'ï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼ºï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½ï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½šï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™';\nconst sup = 'á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾Qá´¿Ë¢áµ€áµâ±½áµ‚Ë£Ê¸á¶»áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–qÊ³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»â°Â¹Â²Â³â´âµâ¶â·â¸â¹â½â¾';\nconst italic = [...'ğ’œğµğ’ğ’Ÿğ¸ğ¹ğ’¢ğ»ğ¼ğ’¥ğ’¦ğ¿ğ‘€ğ’©ğ’ªğ’«ğ’¬ğ‘…ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µğ’¶ğ’·ğ’¸ğ’¹ğ‘’ğ’»ğ‘”ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒğ‘œğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“'];\nconst boldItalic = [...'ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ'];\nconst dia = 'Ã„ÃŸÃ‡ÃÃˆÂ£GHÃŒJKLMÃ±Ã–Ã¾QRÂ§â€ ÃšVWÃ—Â¥ZÃ¥ÃŸÂ¢ÃÃªÂ£ghÃ¯jklmÃ±Ã°Ã¾qrÂ§â€ ÂµvwxÂ¥z'\n\nconst convertText = (name, charset) => {\n    return (\n        delim(name, `'`).map(str => (\n            [...str].map(ch => charset[normal.indexOf(ch)] || ch).join``\n        ))\n    );\n};\n\n// flip\n\nconst flipped = { 'âˆ€': 'A', B: 'ê“­', Æ†: 'C', D: 'ê“·', Æ: 'E', â„²: 'F', ×¤: 'G', H: 'H', I: 'I', Å¿: 'J', Ê: 'K', 'Ë¥': 'L', W: 'M', N: 'N', O: 'O', Ô€: 'P', Q: 'á¿¸', R: 'ê“¤', S: 'S', 'â”´': 'T', 'âˆ©': 'U', Î›: 'V', M: 'W', X: 'X', 'â…„': 'Y', Z: 'Z', a: '\\u0250', b: 'q', c: '\\u0254', d: 'p', e: '\\u01dd', f: '\\u025f', g: 'Æƒ', h: '\\u0265', i: '\\u0131', j: 'É¾', k: 'Ê', l: '×Ÿ', m: '\\u026f', n: 'u', o: 'o', p: 'd', q: 'b', r: '\\u0279', s: 's', t: '\\u0287', u: 'n', v: '\\u028c', w: '\\u028d', x: 'x', y: '\\u028e', z: 'z', '0': '0', Æ–: '1', á„…: '2', Æ: '3', ã„£: '4', Ï›: '5', '9': '6', ã„¥: '7', '8': '8', '6': '9', 'Â¿': '?', 'Â¡': '!', '[': ']', '(': ')', '{': '}', \"'\": ',', '<': '>', '^': 'v', };\n\nObject.entries(flipped).forEach(([k, v]) => {\n    k in flipped || (flipped[k] = v);\n});\n\nconst fliptext = delim('f', `'`).map(str => (\n    [...str].reverse().map(ch => flipped[ch] || ch).join``\n));\n\nconst charset = (start, length) => Array.from({ length }, (_, i) => String.fromCodePoint(start + i)).join``;\n\nconst textReplacement = choice([\n    delim('t', \"'\"), // none\n    convertText('i', italic),\n    convertText('bi', boldItalic),\n    convertText('s', sup),\n    convertText('d', dia),\n    convertText('a', aesthetic),\n    convertText('h', charset(0x3041, 83)), // hiragana\n    convertText('k', charset(0x4e00, 0x89a0)), // kanji\n    fliptext, // f\n]);\n\n// charmaps\n\nconst charmap = (trigger, lookup, _default = trigger) => (\n    sequenceOf([\n        str(trigger),\n        possibly(choice(Object.keys(lookup).map(str))),\n    ]).map(([_, key]) => key ? lookup[key] : _default)\n);\n\nconst star = charmap('*', {\n    '**': 'âŠƒâ”â˜†ï¾Ÿ.*ï½¥ï½¡',\n    '!': 'ğŸ‰',\n    '\"': 'âœ´',\n    'Â£': 'âœ¯',\n    '*': 'â˜…',\n    '$': 'ğŸ—²',\n    '#': 'âœ¿',\n    '+': 'âœ§',\n});\n\nconst heart = charmap('<3', {\n    '!': 'â™¥',\n    '\"': 'â¥',\n}, 'â¤');\n\nconst tilde = charmap('~', {\n    '~': 'ï½',\n    '`': 'ï½ÌÌ€',\n});\n\nconst emotes = charmap(':', {\n    ')': 'ãƒ„',\n});\n\nconst script = recursiveParser(() => possibly(many1(choice([\n    textReplacement,\n    faces,\n    // charsets\n    star,\n    heart,\n    tilde,\n    emotes,\n    // misc\n    asciiCode,\n    whitespace,\n    sequenceOf([ char('.'), regex(/^./) ]).map(([_, c]) => c), // oneChar\n    str('ZWJ').map(()=> String.fromCharCode(0x200b)),\n    str('BELL').map(()=> String.fromCharCode(0x7)),\n]))))\n    .map(arr => arr ? arr.join('') : '');\n\nconst face = (ident) => (fn) => sequenceOf([\n    sequenceOf([\n        ident,\n        many(anyOfString('!\"Â£*')),\n        char('('),\n    ]),\n    possibly(sequenceOf([script, char('^')]).map(([str])=>str)),\n    script,\n    possibly(sequenceOf([char('$'), script]).map(([_, str])=>str)),\n    possibly(sequenceOf([char('?'), script]).map(([_, str])=>str)),\n    char(')'),\n]).map(([[name, mods], left, center, right, optional ]) => {\n    const pound = mods.includes('Â£');\n    const hideWrap = mods.includes('*') || pound;\n    const hideArms = mods.includes('\"');\n    const hideFace = (str) => (mods.includes('!') || pound) ? '' : str;\n    const face = fn({\n        name,\n        dir: /[A-Z]/.test(name),\n        left: (def) => left == null ? hideFace(def) : left,\n        eye: (str) => hideFace(str),\n        center: (def) => center || hideFace(def),\n        right: (def) => right == null ? hideFace(def) : right,\n        arm: (str) => hideArms ? '' : str,\n        wrap: (str) => hideWrap ? str.join`` : `(${str.join``})`,\n        obj: (str) => optional == null ? str : optional,\n    })\n    return Array.isArray(face) ? face.join`` : face;\n});\n\nconst cute = face(anyOfString('cC'))(({ dir, left, right, center, wrap, eye }) => {\n    const eye_ = eye(dir ? 'â—”' : 'â—•');\n    const left_ = dir ? 'âœ¿' : undefined;\n    const right_ = dir ? undefined : 'âœ¿';\n    return wrap([left(left_), eye_, center('â—¡'), eye_, right(right_)]);\n});\n\nconst cool = face(char('x'))(({ left, center, right, wrap, eye }) => {\n    return wrap([left('âŒ'), eye('â– '), center('_'), eye('â– '), right()]);\n});\n\nconst sad = face(char('a'))(({ center, eye }) => {\n    return [eye(`Ê˜`), center('ï¸µ'), eye(`Ê˜`)];\n});\n\nconst lod = face(char('d'))(({ center, eye }) => {\n    return [eye(`à² `), center('_'), eye(`à² `)];\n});\n\nconst actually = face(char('z'))(({ left, center, right, wrap, arm, eye }) => {\n    return [wrap([left(arm('~')), eye('Ë˜'), center('â–¾'), eye('Ë˜'), right()]), arm('~')];\n});\n\nconst shrug = face(char('s'))(({ left, center, right, wrap, arm }) => {\n    return [arm(`Â¯\\\\_`), wrap([left(), center('ãƒ„'), right()]), arm('_/Â¯')];\n});\n\nconst lenny = face(char('v'))(({ left, center, right, wrap, eye }) => {\n    return wrap([left(), eye(' Í¡Â°'), center(' ÍœÊ–'), eye(' Í¡Â°'), right()]);\n});\n\n\nconst flip = face(anyOfString('fF'))(({ dir, left, center, right, wrap, obj, arm, eye }) => {\n    if (dir) {\n        return [obj('â”¬â”€â”€â”¬â—¡'), arm('ï¾‰'), wrap([\n            left(), eye('Â° '), center('-'), eye('Â°'), right(arm('ï¾‰'))\n        ])]\n    }\n    return [wrap([\n        left(arm('â•¯')), eye('Â°'), center('â–¡'), eye('Â°'), right()\n    ]), arm(' â•¯'), 'ï¸µ ', obj('â”»â”â”»')]\n});\n\nconst dumb = face(anyOfString('qQ'))(({ dir, left, right, center, wrap, eye, arm }) => {\n    return [arm('ãƒ˜ '), wrap([\n        left(), eye('Â°ã€‚'[+dir]), center('â–¡'), eye('ã€‚Â°'[+dir]), right()\n    ]), arm(' ãƒ˜')];\n});\n\nconst wizard = face(char('w'))(({ left, right, center, wrap, eye, arm, obj }) => {\n    return [wrap([\n        left(arm('âˆ©')), eye('ï½€'), center('-'), eye('Â´'), right()\n    ]), arm('âŠƒ'), 'â”â˜†ï¾Ÿ.*ï½¥ï½¡ï¾Ÿ ', obj('')];\n});\n\nconst faces = choice([\n    sad,\n    lod,\n    lenny,\n    shrug,\n    cool,\n    actually,\n    cute,\n    flip,\n    dumb,\n    wizard,\n]);\n\nfunction parser(str) {\n    const { result, index } = script.run(str);\n    return str.length == index ? result : result + '// ' + str.slice(index);\n}\n\nprint(parser(input))"
}