{
    "name": "poker.game",
    "command": "// poker.allin\n// poker.setBlind \n// poker.reset -> timers + poker.cancel\n// timers\n// show losers best hand\n// fix bug where bigblind folds\n// probabilities stats royal flush counter\n// more teim / stop timer\n// render winning hand as two messages\n// ~poker.bump timer\n// 19:51 <&nibblr> Kirjava: allow big blind to check before starting the round (6 hours ago)\n// 19:51 <&nibblr> Kirjava: add raise and allin (6 hours ago)\n// score of zero fo worst / all scoreboard\n\n// split pot allocated based on totalBet\n\n\nif (IRC.message.isPM) {\n    throw new Error('cannot into private message');\n}\nIRC.require('poker.deck');\nconst { getScore, setScore, addScore, subScore, addBuyin } = IRC.require('poker.score');\n\nconst isRunning = () => {\n    return typeof store.get('game') != 'undefined';\n};\n\nconst reset = () => {\n    store.set('game', undefined);\n};\n\nconst cmd = (str) => IRC.colors.cmd('poker.' + str);\n\nthis.Game = this.Game || class {\n    constructor() {\n        this.save = () => {\n            const data = JSON.stringify(this);\n            store.set('game', data);\n            return this;\n        };\n        this.load = () => {\n            const data = store.get('game');\n            if (data) {\n                Object.assign(this, JSON.parse(data));\n            }\n            else {\n                throw new Error('no poker game is running');\n            }\n            return this;\n        };\n        this.new = () => {\n            IRC.require('module.count').next();\n            this.players = [];\n            this.status = 'joining';\n            this.table = [];\n            this.blind = 10;\n            this.pot = 0;\n            this.playerIndex = 0;\n            this.voteban = {};\n            const deck = (new Deck()).new(true);\n            print(`{w,dg}        ${deck.drawMany(3).map(d => d.render).join(`{w,dg} {/}`)}{w,dg}   poker™ BETA™  {/}${deck.drawMany(3).map(d => d.render).join(`{w,dg}  {/}`)}{w,dg}        `);\n            print(`use ${IRC.colors.cmd('poker')} to join the game and ${cmd('start')} to begin the game`);\n            deck.new();\n            return this.save();\n        };\n        this.addPlayer = (name) => {\n            if (getScore(name) <= 0) {\n                addBuyin(name);\n                print(`{g}${name}{/} bought back in for {y}$1000{/}`);\n                setScore(name, 1000);\n            }\n            this.players.push({\n                name,\n                cards: [],\n                bet: 0,\n                totalBet: 0,\n                sidePot: 0,\n                fold: false,\n                check: false,\n            });\n            return this.save();\n        };\n        this.deal = () => {\n            const deck = (new Deck()).load();\n            this.players.forEach(player => {\n                player.cards = deck.drawMany(2);\n                notice(player.cards.map(d => d.render).join` `, { target: player.name });\n                store.set('cards$' + player.name, JSON.stringify(player.cards));\n            });\n            return this.save();\n        };\n        this.startRound = () => {\n            const game = this;\n            if (game.players.length < 2) {\n                throw new Error('you need at least two people to play poker');\n            } else if (game.status == 'joining'){\n                //clearTimeout(this.timer);\n                //delete this.timer;\n                this.players = _.shuffle(this.players);\n                print(`Players: ${game.players.map(d => `{g}${d.name}{/}`).join`, `} {dgr}*deals cards*{/} check your {dc}notices{/}`);\n                this.deal();\n                this.status = 'preFlop';\n                // blinds\n                this.players.slice(0, 2)\n                    .forEach((player, i) => {\n                        const blind = (((i+1)*0.5) * this.blind);\n                        this.makeBet(player, blind);\n                        print(`{g}${player.name}{/}: ${i==0?'small ':''}blind {y}$${blind}{/}`)\n                    });\n\n                return this.checkEven();\n            }\n        };\n\n        this.makeBet = (player, amount) => {\n            const score = getScore(player.name);\n            const value = Math.min(amount, score);\n            subScore(player.name, value);\n            player.bet += value;\n            this.pot += value;\n            if (getScore(player.name) == 0) {\n                print(`{g}${player.name}{/} is all in!`)\n            }\n            return value;\n        };\n\n        this.getMaxBet = () => Math.max(...this.players.filter(d => d.fold == false).map(d => d.bet));\n\n        this.checkEven = (pendingMessage = '') => {\n            const maxBet = this.getMaxBet();\n\n            const playersLeft = this.players.filter(d => d.fold == false);\n\n            if (playersLeft.length == 0) {\n                print('everyone folded? okay');\n                reset();\n            } else {\n                const playersToBet = playersLeft.filter(d => (\n                    (d.bet < maxBet || (maxBet == 0 && d.check == false)) && getScore(d.name) > 0\n                ));\n\n                const allChecked = playersLeft.every(d => d.check);\n\n                const playersWithCash = playersLeft.map(d => getScore(d.name)).filter(d => d > 0);\n                const noBettingToDo = playersWithCash.length < 2;\n\n                if (playersLeft.length <= 1 || this.status == 'skip' || ( playersToBet.length == 0 && (maxBet > 0 || allChecked || noBettingToDo) )) {\n                    // allocate total bets\n                    const playersClone = _.cloneDeep(this.players);\n                    this.players.forEach(player => {\n                        player.sidePot += playersClone.map(d => Math.min(d.bet, player.bet)).reduce((a, c) => a + c, 0);\n                        player.totalBet += player.bet;\n                        player.bet = 0;\n                        player.check = false;\n                    });\n                    // remove folds\n                    this.players = this.players.filter(d => d.fold == false);\n\n                    if (playersLeft.length == 1) {\n                        // early win\n                        const player = playersLeft[0];\n                        const amount = Math.min(this.pot, player.sidePot);\n                        this.pot -= amount;\n                        addScore(player.name, amount);\n                        print(`{g}${player.name}{/} won {y}$${amount}{/} and now has {y}$${getScore(player.name)}{/}`);\n                        if (this.pot > 0) {\n                            print(`house takes {y}$${this.pot}{/}`);\n                        }  \n                        reset();\n                    } else {\n                        const renderTable = (stage) => {\n                            print(`{w,dg} ${stage} {/} ${this.table.map(d => d.render).join` `}  Pot: {y}$${this.pot}`);\n                        };\n\n                        // round router\n                        if (noBettingToDo && this.status != 'skip') {\n                            this.status = 'skip';\n                            const deck = (new Deck()).load();\n                            this.table.push(...deck.drawMany(5 - this.table.length));\n                            renderTable('cards');\n                            this.checkEven();\n                        } else if (this.status == 'preFlop') {\n                            this.status = 'flop';\n                            const deck = (new Deck()).load();\n                            const flop = deck.drawMany(3);\n                            this.table.push(...flop);\n                            renderTable('flop');\n                            this.checkEven();\n                        } else if (this.status == 'flop'){\n                            this.status = 'turn';\n                            const deck = (new Deck()).load();\n                            this.table.push(deck.drawOne());\n                            renderTable('turn');\n                            this.checkEven();\n                        } else if (this.status == 'turn') {\n                            this.status = 'river';\n                            const deck = (new Deck()).load();\n                            this.table.push(deck.drawOne());\n                            renderTable('river');\n                            this.checkEven();\n                        } else {\n                            this.save();\n                            (async () => {\n                                try {\n                                    const { getHoldemWinner } = await acquire('poker-calc@0.1.9');\n                                    const finalPlayers = this.players.map((obj, i) => ({ playerId: String(i + 1), ...obj}));\n                                    const results = getHoldemWinner({\n                                        boardCards: this.table,\n                                        playerCards: finalPlayers,\n                                    },{ compactCards: false});\n\n                                    // force split\n                                    //results.push(JSON.parse(JSON.stringify(results[0])))\n                                    //results[1].playerId = results[1].playerId == '1' ? '2': '1';\n\n                                    // print.log(results, {depth: 9})\n\n                                    if (results.length == 0) {\n                                        reset();\n                                        throw new Error('this should never happen');\n                                    } else {\n                                        print(this.players.map(d => `{w,dg} ${d.name} {/} ${d.cards.map(e => e.render).join` `}`).join` `);\n                                        if (results.length == 1) {\n                                            // winner\n                                            const winner = finalPlayers.find(d => d.playerId == results[0].playerId);\n                                            const losers = finalPlayers.filter(d => d.playerId != results[0].playerId);\n                                            const amount = Math.min(this.pot, winner.sidePot);\n                                            this.pot -= amount;\n                                            addScore(winner.name, amount);\n                                            print(`{g}${winner.name}{/} won {y}$${amount}{/} with {g}${results[0].hand.handInfo.type.toLowerCase()}{/} ${results[0].hand.cards.reverse().map(d => d.render).join` `}`);\n                                            if (this.pot > 0) {\n                                                const split = (this.pot / losers.length)|0;\n                                                losers.forEach(loser => {\n                                                    const amount = Math.min(loser.sidePot, split);\n                                                    this.pot -= amount;\n                                                    addScore(loser.name, amount);\n                                                    print(`{g}${loser.name}{/} kept {y}$${amount}{/}`);\n                                                });\n                                            }\n                                        } else {\n                                            // split pot\n                                            const winnerIds = results.map(d => d.playerId);\n                                            const winners = finalPlayers.filter(d => winnerIds.includes(d.playerId));\n                                            const split = (this.pot / winners.length)|0;\n                                            winners.forEach(win => {\n                                                win.amount = Math.min(win.sidePot, split);\n                                                this.pot -= win.amount\n                                                addScore(win.name, win.amount);\n                                            });\n                                            print(`{g}split pot{/} between ${winners.map(d => `{g}${d.name}{/} ({y}$${d.amount}{/})`).join`, `}`);\n                                        }\n                                        if (this.pot > 0) {\n                                            print(`house takes {y}$${this.pot}{/}`);\n                                        }\n                                        reset();\n                                    }\n                                } catch(e) {\n                                    print.log(e);\n                                }\n                            })();\n                        }\n                    }\n\n                } else {\n                    const plural = playersToBet.length > 1;\n                    const message = maxBet > 0 ? `need${plural?'':'s'} to match {y}$${maxBet}{/} -` : cmd('check')+',';\n                    print(`${pendingMessage}${playersToBet.map(d => `{g}${d.name}{/}`).join`, `} ${message} ${cmd('call')}, ${cmd('bet')} {bo}amount{/}, ${cmd('fold')}`);\n                    this.save();\n                }\n            }\n        };\n\n        this.assertCanBet = (name, type) => {\n            if (!isRunning()) {\n                throw new Error('game is not running');\n            } else if (!this.players.some(d => d.name == name)) {\n                throw new Error('you are not playing');\n            } else if (this.status == 'joining') {\n                throw new Error('wait for the game to start');\n            } else if (this.players.find(d => d.name == name).fold) {\n                throw new Error('you have folded');\n            } else if (type == 'check' && (this.getMaxBet() > 0)) {\n                throw new Error('you cannot check when a bet has been made');\n            } else if (type != 'check' && type != 'fold' && getScore(name) <= 0) {\n                throw new Error('you can\\'t afford to bet');\n            }\n        };\n\n        this.info = () => {\n            const player = this.players.find(d => d.name == IRC.message.from);\n            if (player) {\n                print(`stack: {y}$${getScore(player.name)}{/}, bet (round, total): ({y}$${player.bet}{/}, {y}$${player.totalBet}{/})`)\n            }\n        };\n\n        this.check = () => {\n            const name = IRC.message.from;\n            this.assertCanBet(name, 'check');\n            const player = this.players.find(d => d.name == name);\n            player.check = true;\n            return this.checkEven(`{g}${name}{/} has {dc}checked{/} - `);\n        };\n\n        this.call = () => {\n            const name = IRC.message.from;\n            this.assertCanBet(name);\n            const player = this.players.find(d => d.name == name);\n            const maxBet = this.getMaxBet();\n            if (player.bet >= maxBet) {\n                return this.check();\n            }\n            const value = this.makeBet(player, maxBet - player.bet);\n            return this.checkEven(`{g}${player.name}{/} bet {y}$${value}{/} - `);\n        };\n\n        this.bet = () => {\n            const name = IRC.message.from;\n            this.assertCanBet(name);\n            const player = this.players.find(d => d.name == name);\n            const bet = parseInt(input, 10);\n            const maxBet = this.getMaxBet();\n            if (Number.isNaN(bet)) {\n                throw new Error('usage: '+cmd('bet')+' {bo}amount{/}');\n            } else if (bet + player.bet < maxBet && getScore(player.name) > (maxBet - player.bet)) {\n                throw new Error(`${bet + player.bet} < ${maxBet}: bet at least ${maxBet - player.bet}`);\n            }\n            const value = this.makeBet(player, bet);\n            return this.checkEven(`{g}${player.name}{/} bet {y}$${value}{/} - `);\n        };\n\n        this.fold = () => {\n            const name = IRC.message.from;\n            this.assertCanBet(name, 'fold');\n            const player = this.players.find(d => d.name == name);\n            player.fold = true;\n            return this.checkEven(`{g}${name}{/} has {dc}folded{/} - `);\n        };\n\n    }\n}\n\nthis.Game.reset = reset;\nthis.Game.isRunning = isRunning;\n\n",
    "locked": false,
    "starred": false
}