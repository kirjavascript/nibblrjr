{
    "name": "poker.stats",
    "command": "const { getBuyin } = IRC.require('poker.score');\n\nconst showAll = input.includes('all');\nconst showCheat = input.includes('stack') || input.includes('real');\nconst showWorst = input.includes('worst');\nlet scores = store.all().map(({key, value}) => {\n    const buyIns = getBuyin(key);\n    return ({key, value, net: +value + (buyIns*-1000), buyIns })\n})\nscores = _.sortBy(scores, (d) => showCheat ? +d.value : +d.net);\nscores = (showWorst ? scores : scores.reverse())\n.filter(d => !d.key.includes('$') && !isNaN(d.value))\n.reduce((acc, cur) => {\n    const exists = acc.findIndex((d) => d.value === cur.value);\n    if (exists !== -1) {\n        acc[exists].key += `, ${cur.key}`;\n    } else {\n        acc.push(cur);\n    }\n    return acc;\n}, []).slice(0, showAll ? Infinity : 5);\n\nconst longest = scores.reduce((acc, cur) => Math.max(acc, cur.key.length), 0) + 2;\n    \nprint(`{u}Leaderboard{/}`);\nconst colours = ['{y}','{gr}','{o}'];\nscores.forEach(({key, value, net}, i)=> {\n    const pad = longest - key.length - (String(i+1).length - 1);\n    const buyIns = getBuyin(key);\n    const buyInMsg = showCheat && buyIns > 0 ? ` ({y}${buyIns+1}{/} buyins - {y}$${+net}{/})` : '';\n    print(`${i+1}. ${colours[i]||''}${IRC.breakHighlight(key)}{/}{bo}${'.'.repeat(pad>0?pad:0)}{/}{y}$${Intl.NumberFormat().format(showCheat?+value:+net)}{/}${buyInMsg}`)\n})\nprint(`poker has been played {dc}${IRC.require('module.count').count()}{/} times`)",
    "locked": false,
    "starred": false
}