{
    "locked": false,
    "starred": false,
    "name": "r7rpg.dungeon_map",
    "command": "const { from } = IRC.message\nconst { getPlayer, savePlayer } = IRC.require('r7rpg.game')\nplayer = getPlayer()\n\nlet rows = 6\nlet cols = 12\n\nconst maxSplits = 3\nconst splitChance = 30\nlet currentSplits = 0\n\nlet map\n\nif (player.dungeon && player.dungeon.map) {\n  map = player.dungeon.map\n} else {\n  map = []\n}\n\nconst cleanMap = () => {\n  let row = []\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      row.push('')\n    }\n    map.push(row)\n    row = []\n  }\n}\n\nconst debugMap = () => {\n  print(`${JSON.stringify(map)}`)\n}\n\nconst displayMap = (showRoomTypes = false, showBossRoom = false) => {\n  let line = ''\n  for (let i = 0; i < rows; i++) {\n    if (map[i].filter(x => x === '').length != cols) {\n      for (let j = 0; j < map[i].length; j++) {\n        if (i === player.dungeon.current[1] && j === player.dungeon.current[0]) {\n          line += '{bl,c} P {/} '\n        } else {\n          if (map[i][j] === '') {\n            line += '    '\n          } else if (map[i][j] === 'boss' && showRoomTypes || showBossRoom) {\n            line += '{bl,p} B {/} '\n          } else if (map[i][j] === 'treasure' && showRoomTypes) {\n            line += '{bl,y} T {/} '\n          } else if (map[i][j] === 'start') {\n            line += '{bl,c} S {/} '\n          } else if (map[i][j] === 'completed') {\n            line += '{w,g} C {/} '\n          } else if (map[i][j] === 'enemy' && showRoomTypes) {\n            line += '{bl,r} E {/} '\n          } else if (map[i][j] === 'empty' && showRoomTypes) {\n            line += `{bl,w}   {/} `\n          } else {\n            line += `{bl,w}   {/} `\n          }\n        }\n      }\n      print(line)\n      line = ''\n    }\n  }\n}\n\nconst generateMap = (start = 1) => {\n  cleanMap()\n  startLocation(start)\n  const bossY = bossLocation()\n  joinBoss(start, bossY)\n  ensureConnected(start, bossY)\n  return map;\n}\n\nconst getDirections = (x, y) => {\n  let directions = `{dc}${from}{/}: Use` \n  if (getNorth(x, y) && getNorth(x, y) != '') {\n    directions += ` {y}~r7rpg.dungeon north{/}`\n  }\n  if (getEast(x, y) && getEast(x, y) != '') {\n    directions += ` {y}~r7rpg.dungeon east{/}`\n  }\n  if (getSouth(x, y) && getSouth(x, y) != '') {\n    directions += ` {y}~r7rpg.dungeon south{/}`\n  }\n  if (getWest(x, y) && getWest(x, y) != '') {\n    directions += ` {y}~r7rpg.dungeon west{/}`\n  }\n  directions += ` | {y}~r7rpg.dungeon map{/}`\n  return directions\n}\n\nconst checkDirection = (direction) => {\n  const x = player.dungeon.current[0]\n  const y = player.dungeon.current[1]\n  switch (direction) {\n    case 'north':\n      return getNorth(x, y)\n    case 'east':\n      return getEast(x, y)\n    case 'south':\n      return getSouth(x, y)\n    case 'west':\n      return getWest(x, y)\n    default:\n      throw new Error(`{dc}${from}{/}: Unkown direction`)\n  }\n}\n\nconst startLocation = (y) => {\n  setLocation(0, y, 'start')\n  setCurrent(0, y)\n  return y\n}\n\nconst bossLocation = () => {\n  let y = Math.floor(Math.random() * (rows - 1))\n  setLocation(cols - 1, y, 'boss')\n  return y\n}\n\nconst setLocation = (x, y, type, overwrite = false) => {\n  if (y >= 0 && y <= rows && x >= 0 && x <= cols) {\n    if (map[y][x] === '' || overwrite) {\n      map[y][x] = type\n    }\n  } else {\n    throw new Error(`Location out of bounds x: ${x} y: ${y}`)\n  }\n}\n\nconst getMove = (direction) => {\n  const x = player.dungeon.current[0]\n  const y = player.dungeon.current[1]\n  if (player.dungeon.current) {\n    switch (direction) {\n      case 'north':\n        if (getNorth(x, y) && getNorth(x, y) != '') {\n          return [player.dungeon.current[0], player.dungeon.current[1] - 1]\n        } else {\n          return false\n        }\n      case 'east':\n        if (getEast(x, y) && getEast(x, y) != '') {\n          return [player.dungeon.current[0] + 1, player.dungeon.current[1]]\n        } else {\n          return false\n        }\n      case 'south':\n        if (getSouth(x, y) && getSouth(x, y) != '') {\n          return [player.dungeon.current[0], player.dungeon.current[1] + 1]\n        } else {\n          return false\n        }\n      case 'west':\n        if (getWest(x, y) && getWest(x, y) != '') {\n          return [player.dungeon.current[0] - 1, player.dungeon.current[1]]\n        } else {\n          return false\n        }\n      default:\n        throw new Error(`{dc}${from}{/}: Unkown direction`)\n    }\n  } else {\n    throw new Error(`{dc}${from}{/}: Couldn't find current location`)\n  }\n}\n\nconst movePlayer = (direction) => {\n  if (checkDirection(direction)) {\n    const move = getMove(direction)\n    if (move) {\n      setCurrent(move[0], move[1])\n    } else {\n      throw new Error(`{dc}${from}{/}: Unable to move in that direction`)\n    }\n  } else {\n    throw new Error(`{dc}${from}{/}: Unable to move in that direction`)\n  }\n}\n\nconst getCurrent = () => {\n  player = getPlayer()\n  if (player.dungeon.current) {\n  \treturn map[player.dungeon.current[1]][player.dungeon.current[0]]\n  }\n}\n\nconst setCurrent = (x, y) => {\n  if (player.dungeon.current) {\n    map[player.dungeon.current[1]][player.dungeon.current[0]] = 'completed'\n    saveMap()\n  }\n  IRC.require('r7rpg.player').saveDungeonCurrent([x, y])\n}\n\nconst saveMap = () => {\n  IRC.require('r7rpg.player').saveDungeonMap(map)\n}\n\nconst findRoom = (type) => {\n  for (let key in map) {\n    let _map = map[key]\n    if (_map.indexOf(type) != -1) {\n      return [_map.indexOf(type), key]\n    }\n  }\n  return false\n}\n\nconst checkLocationEmpty = (x, y) => {\n  if (map[y][x] === '') {\n    return true\n  } else {\n    return false\n  }\n}\n\nconst checkIsConnected = (x, y, ignore = 0) => {\n  const north = getNorth(x, y)\n  const east = getEast(x, y)\n  const south = getSouth(x, y)\n  const west = getWest(x, y)\n  if (ignore != 1 && north && north != '') {\n    return true\n  }\n  if (ignore != 2 && east && east != '') {\n    return true\n  }\n  if (ignore != 3 && south && south != '') {\n    return true\n  }\n  if (ignore != 4 && west && west != '') {\n    return true\n  }\n  return false\n}\n\nconst getNorth = (x, y) => {\n  if (y - 1 >= 0) {\n    return map[y-1][x]\n  } else {\n    return false\n  }\n}\n\nconst getSouth = (x, y) => {\n  if (y + 1 < rows) {\n    return map[y+1][x]\n  } else {\n    return false\n  }\n}\n\nconst getEast = (x, y) => {\n  if (x + 1 <= cols) {\n    return map[y][x+1]\n  } else {\n    return false\n  }\n}\n\nconst getWest = (x, y) => {\n  if (x - 1 > 0) {\n    return map[y][x-1]\n  } else {\n    return false\n  }\n}\n\nconst randomRoomType = (fork = false) => {\n  const chance = Math.floor(Math.random() * 100)\n  if (fork) {\n    if (chance < 50) {\n      return 'enemy'\n    } else {\n      return 'treasure'\n    }\n  }\n  if (chance < 70) {\n    return 'enemy'\n  }\n  if (chance < 95) {\n    return 'empty'\n  }\n  if (chance >= 95) {\n    return 'treasure'\n  }\n  return 'empty'\n}\n\nconst joinBoss = (y1, y2) => {\n  let splitX = null\n  if (y1 > y2) {\n    splitX = Math.floor(Math.random() * cols - 1) + 1\n    for (let i = y2; i <= y1; i++) {\n      setLocation(splitX, i, randomRoomType())\n    }\n  } else if (y1 < y2) {\n    splitX = Math.floor(Math.random() * cols - 1) + 1\n    for (let i = y1; i <= y2; i++) {\n      setLocation(splitX, i, randomRoomType())\n    }\n  }\n  \n  let currentX = 0\n  let currentY = 0\n  let forks = []\n  \n  for (let i = 1; i < cols; i++) {\n    currentX = i\n    if (splitX) {\n      if (i < splitX) {\n        currentY = y1\n      } else if (i > splitX) {\n        currentY = y2\n      }\n    } else {\n      currentY = y1\n    }\n    setLocation(currentX, currentY, randomRoomType())\n    \n    if (currentSplits < maxSplits && Math.floor(Math.random() * 100) < splitChance) {\n      forks.push([currentX, currentY])\n    }\n  }\n  \n  forks.forEach(element => {\n    createFork(element[0], element[1])\n  })\n}\n\nconst ensureConnected = (x, y) => {\n  if (! checkIsConnected(x, y)) {\n    for (let i = 0; i < rows; i++) {\n      setLocation(cols - 2, i)\n      if (checkIsConnected(x, y)) {\n        break\n      }\n    }\n  }\n}\n\nconst createFork = (x, y) => {\n  let endX = Math.floor(Math.random() * cols)\n  let endY = Math.floor(Math.random() * rows)\n  \n  if (! checkLocationEmpty(endX, endY)) {\n    return\n  }\n  \n  currentSplits++\n  \n  setLocation(endX, endY, randomRoomType(true))\n  \n  let connected = checkIsConnected(endX, endY)\n  \n  if (! connected) {\n    if (endX > x) {\n      for (endX; endX >= x; endX--) {\n        setLocation(endX, endY, randomRoomType())\n        if (checkIsConnected(endX, endY, 2)) {\n          connected = true\n          break\n        }\n      }\n    } else if (endX <= x) {\n      for (endX; endX <= x; endX++) {\n        setLocation(endX, endY, randomRoomType())\n        if (checkIsConnected(endX, endY, 4)) {\n          connected = true\n          break\n        }\n      }\n    }\n    endX = x\n  }\n  \n  if (! connected) {\n    if (endY > y) {\n      endY--\n      for (endY; endY > y; endY--) {\n        setLocation(endX, endY, randomRoomType())\n        if (checkIsConnected(endX, endY, 3)) {\n          break\n        }\n      }\n    } else if (endY < y) {\n      endY++\n      for (endY; endY < y; endY++) {\n        setLocation(endX, endY, randomRoomType())\n        if (checkIsConnected(endX, endY, 1)) {\n          break\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  generateMap,\n  displayMap,\n  getDirections,\n  checkDirection,\n  movePlayer,\n  debugMap,\n  getCurrent\n}"
}