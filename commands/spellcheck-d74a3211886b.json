{
    "name": "spellcheck",
    "command": "function levenshtein(a, b){\n  if(a.length == 0) return b.length; \n  if(b.length == 0) return a.length; \n\n  var matrix = [];\n\n  // increment along the first column of each row\n  var i;\n  for(i = 0; i <= b.length; i++){\n    matrix[i] = [i];\n  }\n\n  // increment each column in the first row\n  var j;\n  for(j = 0; j <= a.length; j++){\n    matrix[0][j] = j;\n  }\n\n  // Fill in the rest of the matrix\n  for(i = 1; i <= b.length; i++){\n    for(j = 1; j <= a.length; j++){\n      if(b.charAt(i-1) == a.charAt(j-1)){\n        matrix[i][j] = matrix[i-1][j-1];\n      } else {\n        matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution\n                                Math.min(matrix[i][j-1] + 1, // insertion\n                                         matrix[i-1][j] + 1)); // deletion\n      }\n    }\n  }\n\n  return matrix[b.length][a.length];\n};\n\n\nconst responses = ['maybe you meant', 'no it is', 'perhaps','have you considered','try this one instead','how about', 'no idiot, it\\'s probably', 'r u dum, it\\'s'];\n\nlet response = responses[Math.floor(Math.random() * responses.length)]\nlet shortest_distance = IRC.wordList.reduce((acc, val) => {\n  let distance = levenshtein(input.toUpperCase(), val);\n  return distance <= acc[0] ? [distance, acc[1].concat([val])] : acc;\n}, [9999999999999,[]]);\n\nshortest_distance[1] = shortest_distance[1].filter(val => {\n\treturn levenshtein(input.toUpperCase(), val) == shortest_distance[0];\n})\n\nif(shortest_distance[0] > 5){\n  throw 'cant find a close enough word :('\n}\n\nif(shortest_distance[0] == 0){\n  print(\"Seems ok\")\n}\nelse{\n  print(`${response} {rand}${shortest_distance[1].map(a => a.toLowerCase()).join(\"{/}, {rand}\")}{/}!`)\n}\n",
    "locked": true,
    "starred": false
}